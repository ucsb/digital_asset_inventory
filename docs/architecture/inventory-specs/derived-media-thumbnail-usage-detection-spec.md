# Derived Media Thumbnail Usage Detection Specification

## Overview

Media entities in Drupal may reference a thumbnail image via their `thumbnail` field. These thumbnail files are typically auto-generated previews (for example, PDF preview images created by contributed modules). These files may reside in directories excluded from filesystem scanning (`thumbnails/`, `oembed_thumbnails/`, `video_thumbnails/`) or in regular content directories (e.g., `public://2026-02/`). In either case, they represent active derived dependencies of Media entities and must not be classified as unused.

This specification introduces relationship-based detection of Media thumbnail usage to ensure such files are correctly tracked as active assets.

## Problem Statement

Currently:

- Some thumbnail files live in directories excluded from scanning: `thumbnails/`, `oembed_thumbnails/`, `video_thumbnails/`.
- Other thumbnail files (e.g., contributed module PDF previews) reside in regular content directories like `public://2026-02/` and ARE processed by the scanner.
- Thumbnail files in excluded directories are invisible to the scanner.
- Thumbnail files in non-excluded directories may lack `file_usage` entries linking them to their Media entity (when generated by contributed modules that bypass standard file tracking).
- In both cases, the files may be incorrectly classified as unused because they have no direct content references.
- Deletion workflows could incorrectly target them, breaking pages that display the thumbnail as a preview image.

This creates a gap in the asset dependency graph.

## Design Principle

This feature follows the core DAI rule:

> System-generated derivative files remain excluded from path-based scanning but are included when discovered through entity relationships.

This is **relationship-driven inclusion**, not path-driven inclusion. The scanner already uses this pattern for external URLs, menu links, and inline embeds.

Relationship discovery occurs only through entity reference fields, not through URI strings or filesystem inspection.

Therefore:

- Thumbnail directories remain excluded from filesystem scanning.
- Thumbnail files are registered only when referenced by Media entities.
- No changes to `excludeSystemGeneratedFiles()`.
- No changes to filesystem orphan scanning.

This feature introduces no new scanning surfaces and does not increase filesystem or entity query scope; it only augments relationships already discovered by the existing scanner.

## Proposed Solution

Two complementary detection paths ensure all thumbnail relationships are captured regardless of directory location or `file_usage` state:

### Path 1 — Forward Detection (from source file)

During Phase 1 scanning, when Media associations are identified for a file, the scanner will:

For each Media entity discovered:

1. Check if it contains a `thumbnail` field.
2. If the field references a file entity:
   - Register the thumbnail file as an asset item (if not already tracked). Asset item creation MUST reuse the existing managed-file registration path (same metadata extraction from `file_managed`, same `fid`-based dedup).
   - Record a usage relationship.

This detection runs as an augmentation to the existing `scanManagedFilesChunk()` media association lookup, not as a separate scan phase. This logic runs only when scanning files that are already associated with Media entities via existing usage detection; it does not independently scan Media entities. Thumbnail asset items are created via relationship discovery even if the thumbnail file would otherwise never be scanned due to excluded directories.

### Path 2 — Reverse Detection (from thumbnail file)

When processing a file that has **no** `file_usage` → media association (`$all_media_ids` is empty), the scanner performs a targeted reverse query to check if this file is used as a thumbnail by any Media entity.

This handles the case where:
- A contributed module generates a thumbnail preview in a non-excluded directory (e.g., `public://2026-02/preview.pdf-p1.jpeg`)
- The generated file has no `file_usage` entry linking it to the Media entity
- The file would otherwise appear as "Local File Not In Use" and could be accidentally deleted

When a reverse match is found:
- Update the asset item's `source_type` to `'media_managed'` and set `media_id`
- Create a usage record with `embed_method = 'derived_thumbnail'`

**Performance guard**: The reverse query only runs for files without `file_usage` → media associations. On most sites, the majority of files HAVE such associations, limiting the query to a small subset of files.

## Usage Classification

A new embed method value is introduced:

| Value | Label | Description |
|-------|-------|-------------|
| `derived_thumbnail` | Thumbnail | Automatically created preview image for this file |

**Meaning**: The file is an automatically created preview image (e.g., a PDF thumbnail). It is not directly embedded in content.

This value joins the existing 12 embed methods without altering their behavior:

| # | Existing Value |
|---|----------------|
| 1 | `field_reference` |
| 2 | `drupal_media` |
| 3 | `html5_video` |
| 4 | `html5_audio` |
| 5 | `text_link` |
| 6 | `inline_image` |
| 7 | `inline_object` |
| 8 | `inline_embed` |
| 9 | `inline_iframe` |
| 10 | `text_url` |
| 11 | `link_field` |
| 12 | `menu_link` |
| **13** | **`derived_thumbnail`** |

## Usage Attribution Rules

Thumbnail usage is attributed to **the Media entity that directly references the thumbnail file**. NOT to the parent content entity that uses the Media.

This maintains consistent single-hop attribution across the DAI usage graph.

**Example:**

```text
Node 5 → references Media 10
Media 10 → references File 42 as thumbnail

Result:
  File 42 usage record:
    host_entity_type = media
    host_entity_id = 10
    embed_method = derived_thumbnail
```

**Rationale:** The existing DAI attribution rule is: primary usage attribution = entity that directly references the asset, not the transitive parent.

| Asset | Usage Attributed To |
|-------|---------------------|
| File in Media field | Media entity |
| Media in Node | Node entity |
| Paragraph in Node | Node entity |
| **Thumbnail of Media** | **Media entity** |

Multi-hop attribution would make the usage graph ambiguous, complicate deduplication, and produce inconsistent CSV exports. The Media entity itself already has usage from content, so the thumbnail is implicitly protected.

## Asset Item Classification

Thumbnail files use the existing `media_managed` source type (the DAI classification for files referenced by Media entities). No new source type is introduced.

Note: Thumbnail files are File entities (tracked in `file_managed`), not Media entities. They use the `media_managed` DAI source classification because they are referenced by Media entities — the same relationship pattern as primary media source files.

**Rationale:** Introducing a separate `derived_managed` source type would add schema complexity without corresponding value: the `embed_method = 'derived_thumbnail'` on the usage record already distinguishes derived dependencies from primary content assets. Filtering, archive eligibility, and cleanup policies can use the embed method rather than a separate source type.

## Phase 1b: External Derived Dependency Providers

Phase 1 detects thumbnails via the Media entity's own `thumbnail` base field. However, some derived file dependencies live **outside** the Media entity — in external entity types provided by contributed modules. These files are active dependencies but are invisible to both `file_usage` and the `thumbnail` field detection path.

### Provider Pattern

External derived dependencies are discovered through a **capability-driven provider pattern**: the scanner checks whether a specific entity type exists via `entityTypeManager->hasDefinition()`, and only runs the provider logic when the entity type is discoverable. This avoids hard dependencies on specific modules — no `moduleExists()` or `class_exists()` calls.

```php
// Capability check — safe when module not installed (code is simply skipped).
if ($this->entityTypeManager->hasDefinition('pdf_image_entity')) {
    // Provider logic here.
}
```

### Provider: `pdf_image_entity` (media_pdf_thumbnail module)

The `media_pdf_thumbnail` contributed module generates JPEG preview images from PDFs and tracks them in `pdf_image_entity` entities. These entities have:

- `referenced_entity_type` — always `'media'` for media-associated previews
- `referenced_entity_id` — the Media entity ID
- `image_file_id` — the generated preview image's file ID

Without this provider, the generated preview images are classified as "Not In Use" because they have no `file_usage` entries and are not referenced by the Media `thumbnail` field.

#### Detection Paths

| Priority | Path | Mechanism |
|----------|------|-----------|
| 3 | Forward | Entity query: `referenced_entity_id IN $all_media_ids` |
| 4 | Reverse | Entity query: `image_file_id = $file->fid` |

**Forward detection** runs inside the `if (!empty($all_media_ids))` block, after the `thumbnail` field loop. It queries `pdf_image_entity` for any entries referencing the current batch of media IDs, then registers each preview image via `registerDerivedFileUsage()`.

**Reverse detection** runs inside the `if (empty($all_media_ids))` block, only when no `thumbnail` field match was found (`empty($thumbnail_media_ids)`). It queries `pdf_image_entity` for entries whose `image_file_id` matches the current file, then updates the asset item's `source_type` to `'media_managed'` and creates usage records.

#### Usage Record Values

| Field | Value | Rationale |
|-------|-------|-----------|
| `entity_type` | `'media'` | Attributed to the Media entity |
| `entity_id` | Media entity ID | From `referenced_entity_id` |
| `field_name` | `'pdf_thumbnail'` | Distinguishes from core `thumbnail` field |
| `embed_method` | `'derived_thumbnail'` | Same as existing — it IS a derived thumbnail |
| `source_type` | `'media_managed'` | Standard for media-associated files |

### Adding Future Providers

Future external derived dependency providers follow the same pattern:

1. Add a `hasDefinition()` capability check for the entity type
2. Query the entity type for relationships to media entities (forward) or file IDs (reverse)
3. Call `registerDerivedFileUsage()` for forward detection
4. Create deduped usage records for reverse detection
5. Use a distinct `field_name` value to differentiate from other providers

## Phase 2: Additional Derived Media Dependencies (Optional, Future)

Phase 1 detects only the `thumbnail` base field — the primary case where a Media entity references a file that is invisible to the standard `file_usage`-based scanner path.

Phase 2 optionally extends detection to additional derived Media file dependencies that are **not** tracked through standard `file_usage` relationships. This includes fields that:

- Reference files not attached as primary media sources (e.g., poster images, transcripts)
- Represent secondary or preview assets added via contributed modules
- May not generate `file_usage` records

Standard Media source fields (the primary file/image field per bundle) already generate `file_usage` records and are handled by the existing scanner. They **must not** be reprocessed by this feature to avoid double-counting.

## Scanner Integration Points

### `scanManagedFilesChunk()` — Augmentation

#### Forward Detection (inside media block)

Add thumbnail detection logic after Media association lookup:

1. Load each associated Media entity.
2. Inspect the `thumbnail` base field.
3. If the thumbnail field references the same `fid` as the file currently being processed, the scanner **MUST** skip (prevents self-referential usage rows).
4. Otherwise, for a different file entity:
   - Create or update the asset item with `source_type = 'media_managed'`.
   - Create a usage record with `embed_method = 'derived_thumbnail'`.

```php
// Pseudocode — forward thumbnail detection
foreach ($media_entities as $media) {
    if (!$media->hasField('thumbnail') || $media->get('thumbnail')->isEmpty()) {
        continue;
    }
    $thumbnail_fid = $media->get('thumbnail')->target_id;
    if ((int) $thumbnail_fid === (int) $file->fid) {
        // Skip — this is the file already being processed.
        continue;
    }
    // Register thumbnail file as asset item (source_type = 'media_managed').
    // Record usage: file($thumbnail_fid) → media($media->id())
    //   with embed_method = 'derived_thumbnail'.
}
```

#### Reverse Detection (after media block)

When `$all_media_ids` is empty (no `file_usage` → media association), query media entities to check if this file is used as a thumbnail:

```php
// Pseudocode — reverse thumbnail detection
if (empty($all_media_ids)) {
    $thumbnail_media_ids = $media_storage->getQuery()
        ->condition('thumbnail.target_id', $file->fid)
        ->accessCheck(FALSE)
        ->execute();

    if (!empty($thumbnail_media_ids)) {
        // Update source_type to 'media_managed'.
        // For each media entity, create derived_thumbnail usage record
        //   (with same 5-field dedup check).
    }
}
```

**Why reverse detection is needed**: When a contributed module generates a thumbnail in a non-excluded directory (e.g., `public://2026-02/preview.pdf-p1.jpeg`), the main scanner loop processes the file as a regular managed file. The forward detection (from the PDF) may have already created a thumbnail asset and usage record, but the main loop's usage clearing (which runs for every file) wipes that record. The reverse detection re-establishes the relationship.

**Deduplication**: Usage creation MUST be idempotent and MUST NOT create duplicate rows across repeated scans. Uniqueness key for usage rows: `asset_id + entity_type + entity_id + field_name + embed_method` (all persisted fields on `digital_asset_usage`). For thumbnail usage, `field_name = 'thumbnail'` and `embed_method = 'derived_thumbnail'`. The implementation MUST include `embed_method` in the dedupe condition (the existing scanner query uses four fields; thumbnail detection adds `embed_method` as the fifth). Code delta: add `->condition('embed_method', 'derived_thumbnail')` to the `existing_usage_query` for thumbnail usage rows.

**Attribution**: For derived thumbnails, the attributed entity (`entity_type + entity_id`) is the Media entity — not the node or other content entity that references the Media. This is consistent with single-hop attribution (see Usage Attribution Rules above).

### `findMediaUsageViaEntityQuery()` — No Changes

Thumbnail detection runs as an augmentation step within `scanManagedFilesChunk()`, not via the entity query method.

### `excludeSystemGeneratedFiles()` — No Changes

Thumbnail directories remain excluded:

- `thumbnails/`
- `oembed_thumbnails/`
- `video_thumbnails/`

These directories contain regeneratable derivatives that should not appear as standalone assets in the inventory.

### Filesystem Orphan Scan — No Changes

Thumbnail directories remain excluded from orphan filesystem scanning. Thumbnails discovered via Media relationships are tracked through `digital_asset_item` and `digital_asset_usage`, not through filesystem scanning.

## Scope

### In Scope

- Detect Media thumbnail file references via the `thumbnail` base field
- Create asset items for thumbnail files (`source_type = 'media_managed'`)
- Record derived usage relationships (`embed_method = 'derived_thumbnail'`)
- Prevent thumbnails from being incorrectly classified as unused
- Thumbnail usage is treated as active usage and prevents deletion under standard in-use policies

### Non-Goals

- Do not attempt to infer thumbnail relationships from file paths or directory naming
- Do not introduce new schema fields or source types

### Out of Scope

- Image style derivatives (remain excluded)
- Regeneratable system files (remain excluded)
- Media icon assets (remain excluded)
- Archiving thumbnails — see Archive Policy below
- Modifying filesystem exclusion logic
- Generating thumbnails
- Detecting thumbnails not stored as entity references (pure derivative files with no managed references)
- Changing Media display behavior

## Edge Cases

### Missing Thumbnail File

If a Media entity's thumbnail reference points to a file that does not exist in `file_managed`:

- Log a scan warning (debug/audit) and skip — do not create any asset item or usage row.

### Media Without Thumbnail Field

If a Media entity does not have a `thumbnail` field (unlikely for core Media, but possible for custom entity types):

- Scanner skips silently.

### Multiple Media Using Same Thumbnail

If multiple Media entities reference the same thumbnail file:

- Multiple usage rows are recorded (one per Media entity).
- The asset item is created once (deduplicated by `fid` / `url_hash`).

### Thumbnail in Non-Excluded Directory

If a contributed module generates a thumbnail in a regular content directory (e.g., `public://2026-02/preview.pdf-p1.jpeg`) rather than an excluded directory:

- The main scanner loop processes the file as a regular managed file.
- Forward detection (from the PDF's processing) creates a thumbnail asset and usage record.
- However, the main loop's usage clearing wipes that record when it processes the thumbnail file.
- Reverse detection re-establishes the `derived_thumbnail` usage by querying media entities for `thumbnail.target_id`.
- The asset's `source_type` is updated from `'file_managed'` to `'media_managed'`.

### Orphan Media

If a Media entity itself is orphaned (not referenced by any content):

- Thumbnail usage remains attributed to the Media entity.
- Orphan classification applies at the Media level, not the file level.
- The thumbnail file still appears as "in use" (it has a valid usage record pointing to the Media entity).
- If the Media entity is later deleted, the thumbnail's usage record is removed and it becomes unused.

### Derived Thumbnail from Non-Image Media

When the derived thumbnail is an image file (e.g., JPEG preview) but the parent Media entity is non-image (e.g., PDF document):

- The asset's `media_id` points to the parent Media entity (the PDF), not an image Media entity.
- **Thumbnail rendering**: `AssetInfoHeader::getMediaThumbnailUrl()` skips non-image media source fields (which would produce broken image style URLs for PDFs) and falls through to `getFileEntityThumbnailUrl()`, which generates a proper image style URL from the JPEG file entity.
- **Alt text**: `AltTextEvaluator::getMediaAltText()` returns `STATUS_NOT_EVALUATED` for non-image source fields (file fields have no `alt` property). The header skips the alt text status line when the result is `STATUS_NOT_EVALUATED`.
- **View/Edit Media actions**: Link to the parent Media entity (the PDF). This is correct — the JPEG has no Media entity of its own; the PDF is the owning entity.
- **Embed type**: Displays "Thumbnail" with tooltip "Automatically created preview image for this file." via the `$embed_labels` and `$embed_tooltips` maps in `MediaSignalsField`.

## Archive Policy

Thumbnail-derived files (`embed_method = 'derived_thumbnail'`) are non-archivable and MUST be excluded from archive workflows and the Archive Registry. Archiving applies only to primary content assets (e.g., the Media source file), not derived preview artifacts.

**Rationale:**

- **Not the authoritative record**: The PDF/video is the thing being preserved for compliance; the thumbnail is a UI preview artifact.
- **Regeneratable**: Thumbnails can be recreated from the source file, so they are not the thing being preserved for audit.
- **Avoids registry clutter**: Archive Registry entries for UI previews would be misleading (e.g., "we archived this image" when the real asset is a PDF).
- **Integrity semantics mismatch**: Checksums and "archived file remains at location" language do not apply to thumbnails that may be re-rendered.

**Enforcement**: No new policy gates are needed. Existing archive eligibility rules (`ArchiveService::canArchive()`) already restrict archiving to Documents and Videos categories. Thumbnails are images and are excluded by this rule.

If a file has multiple usage types including `derived_thumbnail`, archive eligibility is determined by its primary non-derived usage and asset category — the presence of `derived_thumbnail` usage has no effect on archive eligibility.

### Archive Display: Thumbnail Preservation

When a non-image Media entity (e.g., PDF) is archived and has a **derived thumbnail** (a real preview image, not a generic icon), public content pages preserve the thumbnail image wrapped in an archive link instead of replacing the entire media rendering with a text-only link.

**Detection logic** (`hook_preprocess_media`, public content branch):

1. Check if the media's `thumbnail` field has a `target_id` different from the source file `fid`.
2. Load the thumbnail file and verify it is an image MIME type (`image/*`).
3. Verify the thumbnail URI is NOT in a system icon directory (`media-icons/`, `oembed_thumbnails/`, `video_thumbnails/`, `thumbnails/`).
4. If all checks pass, generate an image style URL (`medium`) and render the thumbnail wrapped in an archive link.
5. If any check fails, fall through to the existing text-only archive link behavior.

**Rendered output (with archived label enabled):**

```html
<a href="/archive-registry/{id}" class="dai-archived-link dai-archived-link--thumbnail">
  <img src="...styles/medium/public/.../preview.jpeg" alt="Media Name" loading="lazy" class="dai-archived-thumbnail" />
  <span class="dai-archived-label">(Archived)</span>
</a>
```

**Rationale:**

- Derived thumbnails are meaningful visual previews (e.g., first page of a PDF). Replacing them with text loses valuable context for users.
- Generic media type icons (e.g., PDF icon in `media-icons/`) are NOT preserved — they add no visual value and the text link is sufficient.
- The `medium` image style provides a reasonable preview size for public content without excessive bandwidth.
- The archive link wraps the entire thumbnail, maintaining the routing to the Archive Detail Page.

**CSS**: `.dai-archived-link--thumbnail` uses `display: inline-block`; `.dai-archived-thumbnail` uses `display: block; max-width: 100%` for responsive sizing.

## Performance Considerations

- **Forward detection**: Adds at most one additional field check per Media entity inspected (the `thumbnail` base field). Media entities SHOULD be batch-loaded via `loadMultiple()` per scanner chunk (bounded by the existing chunk size of 50 files) and inspected only for Media IDs already discovered by existing usage detection.
- **Reverse detection**: Adds one media entity query per file that has no `file_usage` → media association. This query is targeted (`condition('thumbnail.target_id', $fid)`) and only runs for the subset of files without media associations. On most sites, the majority of managed files have media associations, so this query runs infrequently.
- No additional filesystem scanning is introduced.

## Acceptance Criteria

1. Thumbnail files referenced by Media entities appear in the inventory.
2. They are marked as active usage (never appear as "unused").
3. They never appear as orphan files or unused assets.
4. Directory exclusion rules remain unchanged (`thumbnails/`, `oembed_thumbnails/`, `video_thumbnails/` still excluded from filesystem scanning).
5. Usage attribution points to Media entities (single-hop, not transitive to parent content).
6. Asset items use `source_type = 'media_managed'`.
7. Usage records use `embed_method = 'derived_thumbnail'`.
8. No code path checks for specific module enablement (`moduleHandler->moduleExists()` must NOT be used).
9. No double-counting when discovered from multiple scan paths.
10. Thumbnail files in non-excluded directories (e.g., contrib module PDF previews) are detected via reverse media entity query and classified as `'media_managed'` with `derived_thumbnail` usage.
11. External derived dependencies (e.g., `pdf_image_entity`) are detected when the entity type exists (capability check via `hasDefinition()`). Usage records use `field_name = 'pdf_thumbnail'` to distinguish from core `thumbnail` field.
12. Usage detail page displays correctly for derived thumbnails: header renders the image thumbnail (not the parent PDF), embed type shows "Thumbnail" with tooltip, alt text section is hidden for non-image parent media, View/Edit Media links to the parent Media entity.
13. When an archived non-image media has a derived thumbnail (real preview image, not a generic icon), public content pages display the thumbnail image wrapped in an archive link instead of a text-only link. Generic icon thumbnails fall through to text-only display.

## Verification

### Manual

1. Upload a PDF to a Media entity (or use a contributed module that generates a thumbnail preview).
2. Reference the Media entity in content.
3. Run the Digital Asset Inventory scan.
4. **Expected**:
   - Thumbnail image appears in inventory.
   - Usage type = `derived_thumbnail`.
   - Host entity = Media entity (not the content node).
   - Source type = `media_managed`.
   - Thumbnail directories remain excluded from filesystem scanning.

### Automated Tests

Kernel tests must verify:

- **Thumbnail detection**: Given a Media entity with a `thumbnail` field referencing a file, the scanner creates an asset item with `source_type = 'media_managed'` and a usage record with `embed_method = 'derived_thumbnail'`.
- **Asset item creation**: Thumbnail asset item has correct `fid`, `source_type`, and file metadata.
- **Usage attribution correctness**: Usage record points to the Media entity (`entity_type = 'media'`, `entity_id = $mid`), not to any parent content entity.
- **No duplication**: Same thumbnail discovered through multiple paths yields one asset item and no duplicate usage rows.
- **Active usage policy**: A file with only `derived_thumbnail` usage is treated as "in use" for deletion policy (deletion is blocked).
- **Empty thumbnail field**: Media entity with empty/missing `thumbnail` field creates no asset item or usage row.

## Affected Files

### Phase 1 (v1.31.0) — Core thumbnail field detection

| File | Action | Purpose |
|------|--------|---------|
| `src/Service/DigitalAssetScanner.php` | MODIFY | Add `registerDerivedFileUsage()`, thumbnail detection in `scanManagedFilesChunk()` |
| `src/Entity/DigitalAssetUsage.php` | MODIFY | Add `derived_thumbnail` to embed method description |
| `docs/architecture/inventory-specs/usage-detection-spec.md` | MODIFY | Add `derived_thumbnail` to embed method table |
| `tests/src/Kernel/ThumbnailUsageKernelTest.php` | CREATE | Kernel tests for thumbnail usage detection (8 tests) |
| `CLAUDE.md` | MODIFY | Update embed method table and changelog |

### Phase 1b (v1.31.1) — External providers and display fixes

| File | Action | Purpose |
|------|--------|---------|
| `src/Service/DigitalAssetScanner.php` | MODIFY | Add `pdf_image_entity` forward + reverse provider blocks |
| `src/Plugin/views/field/MediaSignalsField.php` | MODIFY | Add `derived_thumbnail` → "Thumbnail" to embed type labels with tooltip |
| `src/Service/AltTextEvaluator.php` | MODIFY | Guard `getMediaAltText()` against non-image source fields |
| `src/Plugin/views/area/AssetInfoHeader.php` | MODIFY | Skip alt text for non-image media; skip media thumbnail for non-image source fields (fall through to file entity thumbnail) |
| `digital_asset_inventory.module` | MODIFY | Preserve derived thumbnail in `hook_preprocess_media` public content branch for archived non-image media |
| `css/dai-public.css` | MODIFY | Add `.dai-archived-link--thumbnail` and `.dai-archived-thumbnail` styles |
| `CLAUDE.md` | MODIFY | Changelog entry for v1.31.1 |
