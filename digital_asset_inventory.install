<?php

/**
 * @file
 * Install, update and uninstall functions for Digital Asset Inventory module.
 */

use Drupal\user\Entity\Role;
use Drupal\views\Entity\View;

/**
 * Implements hook_install().
 */
function digital_asset_inventory_install() {
  // Check for /archive-registry path conflicts before enabling archive features.
  $conflict = _digital_asset_inventory_check_archive_path_conflict();

  if (!empty($conflict)) {
    // Disable the public_archive View to prevent route conflict.
    $view = View::load('public_archive');
    if ($view) {
      $view->disable();
      $view->save();
    }

    // Ensure archive feature is disabled in config.
    \Drupal::configFactory()
      ->getEditable('digital_asset_inventory.settings')
      ->set('enable_archive', FALSE)
      ->set('enable_manual_archive', FALSE)
      ->save();

    $conflict_list = '<ul><li>' . implode('</li><li>', $conflict) . '</li></ul>';
    $future_note = '<p><em>' . t('Note: A future release may allow the Archive Registry to use an alternate path (e.g., /digital-archive) when /archive-registry is already in use, but this version requires exclusivity for /archive-registry.') . '</em></p>';
    \Drupal::messenger()->addWarning(new \Drupal\Component\Render\FormattableMarkup(
      t('Digital Asset Inventory: The path <a href="@archive_url">/archive-registry</a> is already in use on this site. The Archive Registry feature has been disabled. To enable it, remove the following conflicts, then enable Archive functionality in the module settings:', ['@archive_url' => '/archive-registry']) . $conflict_list . $future_note,
      []
    ));

    \Drupal::logger('digital_asset_inventory')->warning('Archive Registry disabled due to /archive-registry path conflict.');
  }

  // Ensure the Digital Asset Manager role has the necessary permissions.
  $role = Role::load('digital_asset_manager');

  if ($role) {
    $permissions = [
      'access toolbar',
      'view digital asset inventory',
      'scan digital assets',
      'delete digital assets',
      'archive digital assets',
    ];

    foreach ($permissions as $permission) {
      if (!$role->hasPermission($permission)) {
        $role->grantPermission($permission);
      }
    }

    $role->save();

    \Drupal::logger('digital_asset_inventory')->notice('Digital Asset Manager role permissions have been configured.');
  }

  // Enable archive link filter on HTML text formats.
  _digital_asset_inventory_enable_archive_filter_on_formats();
}

/**
 * Checks if /archive-registry path is already in use.
 *
 * @return array
 *   Array of conflict descriptions, empty if no conflicts.
 */
function _digital_asset_inventory_check_archive_path_conflict() {
  $database = \Drupal::database();
  $entity_type_manager = \Drupal::entityTypeManager();
  $module_handler = \Drupal::moduleHandler();
  $conflicts = [];

  // 1. Check path aliases for /archive-registry.
  try {
    $aliases = $database->select('path_alias', 'pa')
      ->fields('pa', ['path', 'alias'])
      ->condition('alias', '/archive-registry')
      ->execute()
      ->fetchAll();
    foreach ($aliases as $alias) {
      $conflicts[] = t('Path alias: @source → @alias', [
        '@source' => $alias->path,
        '@alias' => $alias->alias,
      ]);
    }
  }
  catch (\Exception $e) {
    // Table may not exist yet.
  }

  // 2. Check Views for /archive-registry path (excluding our own).
  if (class_exists('\Drupal\views\Views')) {
    $views = \Drupal\views\Views::getAllViews();
    foreach ($views as $view) {
      if ($view->id() === 'public_archive') {
        continue;
      }
      $displays = $view->get('display');
      foreach ($displays as $display) {
        if (isset($display['display_options']['path']) && $display['display_options']['path'] === 'archive-registry') {
          $conflicts[] = t('View: @label (@id) - edit at /admin/structure/views/view/@id', [
            '@label' => $view->label(),
            '@id' => $view->id(),
          ]);
          break;
        }
      }
    }
  }

  // 3. Check menu links pointing to /archive-registry.
  try {
    $menu_links = $entity_type_manager->getStorage('menu_link_content')
      ->loadByProperties(['link__uri' => 'internal:/archive-registry']);
    foreach ($menu_links as $link) {
      $conflicts[] = t('Menu link: @title in @menu menu', [
        '@title' => $link->getTitle(),
        '@menu' => $link->getMenuName(),
      ]);
    }
  }
  catch (\Exception $e) {
    // Entity type may not exist.
  }

  // 4. Check Redirect module entries.
  if ($module_handler->moduleExists('redirect')) {
    try {
      $redirects = $database->select('redirect', 'r')
        ->fields('r', ['rid', 'redirect_source__path', 'redirect_redirect__uri'])
        ->condition('redirect_source__path', 'archive-registry')
        ->execute()
        ->fetchAll();
      foreach ($redirects as $redirect) {
        $conflicts[] = t('URL Redirect: /archive-registry → @target - edit at /admin/config/search/redirect/edit/@rid', [
          '@target' => $redirect->redirect_redirect__uri,
          '@rid' => $redirect->rid,
        ]);
      }
    }
    catch (\Exception $e) {
      // Table may not exist.
    }
  }

  // 5. Check for custom routes at /archive-registry.
  try {
    $route_provider = \Drupal::service('router.route_provider');
    $routes = $route_provider->getRoutesByPattern('/archive-registry');
    foreach ($routes as $route_name => $route) {
      // Skip our module's routes.
      if (strpos($route_name, 'digital_asset_inventory.') === 0 ||
          strpos($route_name, 'view.public_archive.') === 0) {
        continue;
      }
      $conflicts[] = t('Custom route: @name', ['@name' => $route_name]);
    }
  }
  catch (\Exception $e) {
    // Route provider error.
  }

  return $conflicts;
}

/**
 * Enables the archive link filter on HTML-processing text formats.
 *
 * This function enables the "Route archived file links to Archive Detail Page"
 * filter on text formats that output HTML content. It detects HTML formats by:
 * - Checking for HTML-related filters (filter_html, media_embed, etc.)
 * - Checking format names/IDs for patterns (html, rich, markdown, wysiwyg)
 * - Excluding known plain text formats
 *
 * @return array
 *   Array of format labels that were updated.
 */
function _digital_asset_inventory_enable_archive_filter_on_formats() {
  $config_factory = \Drupal::configFactory();
  $updated_formats = [];

  // Get all filter format configurations.
  $format_configs = $config_factory->listAll('filter.format.');

  foreach ($format_configs as $config_name) {
    $format = $config_factory->getEditable($config_name);
    $filters = $format->get('filters') ?? [];
    $format_id = $format->get('format');
    $format_label = $format->get('name') ?? $format_id;

    // Skip if already has our filter enabled.
    if (isset($filters['digital_asset_archive_link_filter']['status']) &&
        $filters['digital_asset_archive_link_filter']['status'] === TRUE) {
      continue;
    }

    // Skip known plain text formats.
    $plain_text_patterns = ['plain', 'restricted'];
    $is_plain_text = FALSE;
    foreach ($plain_text_patterns as $pattern) {
      if (stripos($format_id, $pattern) !== FALSE) {
        $is_plain_text = TRUE;
        break;
      }
    }
    if ($is_plain_text) {
      continue;
    }

    // Check if this format outputs HTML content.
    $outputs_html = FALSE;

    // 1. Check for HTML-related filters.
    $html_filters = [
      'filter_html',
      'filter_htmlcorrector',
      'editor_file_reference',
      'media_embed',
      'filter_autop',
      'filter_url',
      'markdown',
    ];
    foreach ($html_filters as $filter) {
      if (isset($filters[$filter]['status']) && $filters[$filter]['status'] === TRUE) {
        $outputs_html = TRUE;
        break;
      }
    }

    // 2. Check format ID/name for HTML-related patterns.
    if (!$outputs_html) {
      $html_patterns = ['html', 'rich', 'wysiwyg', 'editor', 'ckeditor', 'markdown', 'full', 'basic'];
      foreach ($html_patterns as $pattern) {
        if (stripos($format_id, $pattern) !== FALSE || stripos($format_label, $pattern) !== FALSE) {
          $outputs_html = TRUE;
          break;
        }
      }
    }

    // 3. If format has any filters and isn't plain text, assume it outputs HTML.
    if (!$outputs_html && !empty($filters)) {
      $outputs_html = TRUE;
    }

    if ($outputs_html) {
      // Add our filter with high weight so it runs after other transformations.
      $filters['digital_asset_archive_link_filter'] = [
        'id' => 'digital_asset_archive_link_filter',
        'provider' => 'digital_asset_inventory',
        'status' => TRUE,
        'weight' => 100,
        'settings' => [],
      ];

      $format->set('filters', $filters);
      $format->save();
      $updated_formats[] = $format_label;
    }
  }

  return $updated_formats;
}

/**
 * Fix Views configurations for Drupal 11 schema compliance.
 */
function digital_asset_inventory_update_10001() {
  $config_factory = \Drupal::configFactory();
  $messages = [];

  // Fix digital_asset_archive view - move menu options inside menu block.
  $archive_view = $config_factory->getEditable('views.view.digital_asset_archive');
  if (!$archive_view->isNew()) {
    $display_options = $archive_view->get('display.page_archive_management.display_options');
    if ($display_options) {
      $changed = FALSE;

      // Check if menu options are at wrong level and move them.
      $menu_options = ['expanded', 'menu_name', 'parent', 'context'];
      foreach ($menu_options as $option) {
        if (isset($display_options[$option])) {
          // Move to menu block if menu exists.
          if (isset($display_options['menu'])) {
            $display_options['menu'][$option] = $display_options[$option];
          }
          unset($display_options[$option]);
          $changed = TRUE;
        }
      }

      if ($changed) {
        $archive_view->set('display.page_archive_management.display_options', $display_options);
        $archive_view->save();
        $messages[] = t('Fixed digital_asset_archive view menu configuration.');
      }
    }
  }

  // Fix digital_asset_usage view - remove invalid validate_options.
  $usage_view = $config_factory->getEditable('views.view.digital_asset_usage');
  if (!$usage_view->isNew()) {
    $validate_options = $usage_view->get('display.default.display_options.arguments.asset_id.validate_options');
    if ($validate_options && (isset($validate_options['min']) || isset($validate_options['max']))) {
      // Remove min/max if they're empty strings (invalid for numeric).
      if (($validate_options['min'] ?? '') === '' && ($validate_options['max'] ?? '') === '') {
        $usage_view->set('display.default.display_options.arguments.asset_id.validate_options', []);
        $usage_view->save();
        $messages[] = t('Fixed digital_asset_usage view validate_options.');
      }
    }
  }

  // Fix public_archive view - remove placeholder from boolean filter.
  $public_view = $config_factory->getEditable('views.view.public_archive');
  if (!$public_view->isNew()) {
    $expose = $public_view->get('display.default.display_options.filters.flag_missing.expose');
    if ($expose && isset($expose['placeholder'])) {
      unset($expose['placeholder']);
      $public_view->set('display.default.display_options.filters.flag_missing.expose', $expose);
      $public_view->save();
      $messages[] = t('Fixed public_archive view filter configuration.');
    }
  }

  if (empty($messages)) {
    return t('Views configurations already up to date.');
  }

  return implode(' ', $messages);
}

/**
 * Update digital_asset_usage view with enhanced entity info columns.
 *
 * Adds new columns: Content (title with link), Type, Content Type, Field,
 * Required, and an asset info header above the table.
 */
function digital_asset_inventory_update_10002() {
  $config_factory = \Drupal::configFactory();
  $usage_view = $config_factory->getEditable('views.view.digital_asset_usage');

  if ($usage_view->isNew()) {
    return t('digital_asset_usage view not found. It may need to be reinstalled.');
  }

  // Update the view with new field configuration.
  $display_options = $usage_view->get('display.default.display_options');

  // Add header for asset info.
  $display_options['header'] = [
    'asset_info_header' => [
      'id' => 'asset_info_header',
      'table' => 'digital_asset_usage',
      'field' => 'asset_info_header',
      'relationship' => 'none',
      'group_type' => 'group',
      'admin_label' => '',
      'plugin_id' => 'digital_asset_info_header',
      'empty' => FALSE,
    ],
  ];

  // Define the new fields configuration.
  $new_fields = [
    'usage_title' => [
      'id' => 'usage_title',
      'table' => 'digital_asset_usage',
      'field' => 'usage_entity_info',
      'relationship' => 'none',
      'group_type' => 'group',
      'admin_label' => '',
      'plugin_id' => 'digital_asset_usage_entity_info',
      'label' => 'Content',
      'exclude' => FALSE,
      'alter' => [
        'alter_text' => FALSE,
        'text' => '',
        'make_link' => FALSE,
        'path' => '',
        'absolute' => FALSE,
        'external' => FALSE,
        'replace_spaces' => FALSE,
        'path_case' => 'none',
        'trim_whitespace' => FALSE,
        'alt' => '',
        'rel' => '',
        'link_class' => '',
        'prefix' => '',
        'suffix' => '',
        'target' => '',
        'nl2br' => FALSE,
        'max_length' => 0,
        'word_boundary' => TRUE,
        'ellipsis' => TRUE,
        'more_link' => FALSE,
        'more_link_text' => '',
        'more_link_path' => '',
        'strip_tags' => FALSE,
        'trim' => FALSE,
        'preserve_tags' => '',
        'html' => FALSE,
      ],
      'element_type' => '',
      'element_class' => '',
      'element_label_type' => '',
      'element_label_class' => '',
      'element_label_colon' => TRUE,
      'element_wrapper_type' => '',
      'element_wrapper_class' => '',
      'element_default_classes' => TRUE,
      'empty' => '',
      'hide_empty' => FALSE,
      'empty_zero' => FALSE,
      'hide_alter_empty' => TRUE,
      'display_mode' => 'title',
    ],
    'usage_entity_type' => [
      'id' => 'usage_entity_type',
      'table' => 'digital_asset_usage',
      'field' => 'usage_entity_info',
      'relationship' => 'none',
      'group_type' => 'group',
      'admin_label' => '',
      'plugin_id' => 'digital_asset_usage_entity_info',
      'label' => 'Type',
      'exclude' => FALSE,
      'alter' => [
        'alter_text' => FALSE,
        'text' => '',
        'make_link' => FALSE,
        'path' => '',
        'absolute' => FALSE,
        'external' => FALSE,
        'replace_spaces' => FALSE,
        'path_case' => 'none',
        'trim_whitespace' => FALSE,
        'alt' => '',
        'rel' => '',
        'link_class' => '',
        'prefix' => '',
        'suffix' => '',
        'target' => '',
        'nl2br' => FALSE,
        'max_length' => 0,
        'word_boundary' => TRUE,
        'ellipsis' => TRUE,
        'more_link' => FALSE,
        'more_link_text' => '',
        'more_link_path' => '',
        'strip_tags' => FALSE,
        'trim' => FALSE,
        'preserve_tags' => '',
        'html' => FALSE,
      ],
      'element_type' => '',
      'element_class' => '',
      'element_label_type' => '',
      'element_label_class' => '',
      'element_label_colon' => TRUE,
      'element_wrapper_type' => '',
      'element_wrapper_class' => '',
      'element_default_classes' => TRUE,
      'empty' => '',
      'hide_empty' => FALSE,
      'empty_zero' => FALSE,
      'hide_alter_empty' => TRUE,
      'display_mode' => 'entity_type',
    ],
    'usage_bundle' => [
      'id' => 'usage_bundle',
      'table' => 'digital_asset_usage',
      'field' => 'usage_entity_info',
      'relationship' => 'none',
      'group_type' => 'group',
      'admin_label' => '',
      'plugin_id' => 'digital_asset_usage_entity_info',
      'label' => 'Content Type',
      'exclude' => FALSE,
      'alter' => [
        'alter_text' => FALSE,
        'text' => '',
        'make_link' => FALSE,
        'path' => '',
        'absolute' => FALSE,
        'external' => FALSE,
        'replace_spaces' => FALSE,
        'path_case' => 'none',
        'trim_whitespace' => FALSE,
        'alt' => '',
        'rel' => '',
        'link_class' => '',
        'prefix' => '',
        'suffix' => '',
        'target' => '',
        'nl2br' => FALSE,
        'max_length' => 0,
        'word_boundary' => TRUE,
        'ellipsis' => TRUE,
        'more_link' => FALSE,
        'more_link_text' => '',
        'more_link_path' => '',
        'strip_tags' => FALSE,
        'trim' => FALSE,
        'preserve_tags' => '',
        'html' => FALSE,
      ],
      'element_type' => '',
      'element_class' => '',
      'element_label_type' => '',
      'element_label_class' => '',
      'element_label_colon' => TRUE,
      'element_wrapper_type' => '',
      'element_wrapper_class' => '',
      'element_default_classes' => TRUE,
      'empty' => '',
      'hide_empty' => FALSE,
      'empty_zero' => FALSE,
      'hide_alter_empty' => TRUE,
      'display_mode' => 'bundle',
    ],
    'usage_field' => [
      'id' => 'usage_field',
      'table' => 'digital_asset_usage',
      'field' => 'usage_entity_info',
      'relationship' => 'none',
      'group_type' => 'group',
      'admin_label' => '',
      'plugin_id' => 'digital_asset_usage_entity_info',
      'label' => 'Field',
      'exclude' => FALSE,
      'alter' => [
        'alter_text' => FALSE,
        'text' => '',
        'make_link' => FALSE,
        'path' => '',
        'absolute' => FALSE,
        'external' => FALSE,
        'replace_spaces' => FALSE,
        'path_case' => 'none',
        'trim_whitespace' => FALSE,
        'alt' => '',
        'rel' => '',
        'link_class' => '',
        'prefix' => '',
        'suffix' => '',
        'target' => '',
        'nl2br' => FALSE,
        'max_length' => 0,
        'word_boundary' => TRUE,
        'ellipsis' => TRUE,
        'more_link' => FALSE,
        'more_link_text' => '',
        'more_link_path' => '',
        'strip_tags' => FALSE,
        'trim' => FALSE,
        'preserve_tags' => '',
        'html' => FALSE,
      ],
      'element_type' => '',
      'element_class' => '',
      'element_label_type' => '',
      'element_label_class' => '',
      'element_label_colon' => TRUE,
      'element_wrapper_type' => '',
      'element_wrapper_class' => '',
      'element_default_classes' => TRUE,
      'empty' => '',
      'hide_empty' => FALSE,
      'empty_zero' => FALSE,
      'hide_alter_empty' => TRUE,
      'display_mode' => 'field_name',
    ],
    'usage_required' => [
      'id' => 'usage_required',
      'table' => 'digital_asset_usage',
      'field' => 'usage_entity_info',
      'relationship' => 'none',
      'group_type' => 'group',
      'admin_label' => '',
      'plugin_id' => 'digital_asset_usage_entity_info',
      'label' => 'Required',
      'exclude' => FALSE,
      'alter' => [
        'alter_text' => FALSE,
        'text' => '',
        'make_link' => FALSE,
        'path' => '',
        'absolute' => FALSE,
        'external' => FALSE,
        'replace_spaces' => FALSE,
        'path_case' => 'none',
        'trim_whitespace' => FALSE,
        'alt' => '',
        'rel' => '',
        'link_class' => '',
        'prefix' => '',
        'suffix' => '',
        'target' => '',
        'nl2br' => FALSE,
        'max_length' => 0,
        'word_boundary' => TRUE,
        'ellipsis' => TRUE,
        'more_link' => FALSE,
        'more_link_text' => '',
        'more_link_path' => '',
        'strip_tags' => FALSE,
        'trim' => FALSE,
        'preserve_tags' => '',
        'html' => FALSE,
      ],
      'element_type' => '',
      'element_class' => '',
      'element_label_type' => '',
      'element_label_class' => '',
      'element_label_colon' => TRUE,
      'element_wrapper_type' => '',
      'element_wrapper_class' => '',
      'element_default_classes' => TRUE,
      'empty' => '',
      'hide_empty' => FALSE,
      'empty_zero' => FALSE,
      'hide_alter_empty' => TRUE,
      'display_mode' => 'field_required',
    ],
    'count' => [
      'id' => 'count',
      'table' => 'digital_asset_usage',
      'field' => 'count',
      'relationship' => 'none',
      'group_type' => 'group',
      'admin_label' => '',
      'plugin_id' => 'field',
      'label' => 'Uses',
      'exclude' => FALSE,
      'alter' => [
        'alter_text' => FALSE,
        'text' => '',
        'make_link' => FALSE,
        'path' => '',
        'absolute' => FALSE,
        'external' => FALSE,
        'replace_spaces' => FALSE,
        'path_case' => 'none',
        'trim_whitespace' => FALSE,
        'alt' => '',
        'rel' => '',
        'link_class' => '',
        'prefix' => '',
        'suffix' => '',
        'target' => '',
        'nl2br' => FALSE,
        'max_length' => 0,
        'word_boundary' => TRUE,
        'ellipsis' => TRUE,
        'more_link' => FALSE,
        'more_link_text' => '',
        'more_link_path' => '',
        'strip_tags' => FALSE,
        'trim' => FALSE,
        'preserve_tags' => '',
        'html' => FALSE,
      ],
      'element_type' => '',
      'element_class' => '',
      'element_label_type' => '',
      'element_label_class' => '',
      'element_label_colon' => TRUE,
      'element_wrapper_type' => '',
      'element_wrapper_class' => '',
      'element_default_classes' => TRUE,
      'empty' => '',
      'hide_empty' => FALSE,
      'empty_zero' => FALSE,
      'hide_alter_empty' => TRUE,
    ],
  ];

  $display_options['fields'] = $new_fields;

  // Update the table style columns.
  $display_options['style']['options']['columns'] = [
    'usage_title' => 'usage_title',
    'usage_entity_type' => 'usage_entity_type',
    'usage_bundle' => 'usage_bundle',
    'usage_field' => 'usage_field',
    'usage_required' => 'usage_required',
    'count' => 'count',
  ];

  $display_options['style']['options']['info'] = [
    'usage_title' => [
      'sortable' => FALSE,
      'default_sort_order' => 'asc',
      'align' => '',
      'separator' => '',
      'empty_column' => FALSE,
      'responsive' => '',
    ],
    'usage_entity_type' => [
      'sortable' => FALSE,
      'default_sort_order' => 'asc',
      'align' => '',
      'separator' => '',
      'empty_column' => FALSE,
      'responsive' => '',
    ],
    'usage_bundle' => [
      'sortable' => FALSE,
      'default_sort_order' => 'asc',
      'align' => '',
      'separator' => '',
      'empty_column' => FALSE,
      'responsive' => '',
    ],
    'usage_field' => [
      'sortable' => FALSE,
      'default_sort_order' => 'asc',
      'align' => '',
      'separator' => '',
      'empty_column' => FALSE,
      'responsive' => '',
    ],
    'usage_required' => [
      'sortable' => FALSE,
      'default_sort_order' => 'asc',
      'align' => '',
      'separator' => '',
      'empty_column' => FALSE,
      'responsive' => '',
    ],
    'count' => [
      'sortable' => FALSE,
      'default_sort_order' => 'desc',
      'align' => '',
      'separator' => '',
      'empty_column' => FALSE,
      'responsive' => '',
    ],
  ];

  $usage_view->set('display.default.display_options', $display_options);
  $usage_view->save();

  // Clear plugin caches to ensure new Views plugins are discovered.
  // This is more targeted than drupal_flush_all_caches() and works in D10/D11.
  \Drupal::service('plugin.cache_clearer')->clearCachedDefinitions();

  // Also clear render cache and views data cache.
  \Drupal::cache('render')->invalidateAll();
  if (\Drupal::hasService('cache.views_info')) {
    \Drupal::cache('views_info')->invalidateAll();
  }

  return t('Updated digital_asset_usage view with enhanced entity info columns and asset info header.');
}

/**
 * Update digital_asset_usage view column labels for clarity.
 *
 * Changes: Content → Used On, Type → Item Type, Content Type → Item Category,
 * Field → Section, Required → Required Field, Uses → Times Used.
 */
function digital_asset_inventory_update_10003() {
  $config_factory = \Drupal::configFactory();
  $usage_view = $config_factory->getEditable('views.view.digital_asset_usage');

  if ($usage_view->isNew()) {
    return t('digital_asset_usage view not found.');
  }

  // Update field labels.
  $label_updates = [
    'usage_title' => 'Used On',
    'usage_entity_type' => 'Item Type',
    'usage_bundle' => 'Item Category',
    'usage_field' => 'Section',
    'usage_required' => 'Required Field',
    'count' => 'Times Used',
  ];

  foreach ($label_updates as $field_id => $new_label) {
    $label_path = "display.default.display_options.fields.{$field_id}.label";
    if ($usage_view->get($label_path) !== NULL) {
      $usage_view->set($label_path, $new_label);
    }
  }

  $usage_view->save();

  return t('Updated digital_asset_usage view column labels.');
}

/**
 * Update digital_asset_archive view header content.
 *
 * Removes redundant h2 heading and updates intro text with archiving
 * restriction notice.
 */
function digital_asset_inventory_update_10004() {
  $config_factory = \Drupal::configFactory();
  $archive_view = $config_factory->getEditable('views.view.digital_asset_archive');

  if ($archive_view->isNew()) {
    return t('digital_asset_archive view not found.');
  }

  // Get current header content.
  $content = $archive_view->get('display.default.display_options.header.area_text_custom.content');

  if ($content) {
    // New intro text (without h2 heading).
    $new_intro = "<p>\r\n  <strong>Archiving restriction:</strong> Materials may not be archived if they are actively used for learning, onboarding, compliance, operational work, or any current decision-making processes.\r\n</p>\r\n<p>\r\n  Archived materials are retained for reference, research, or recordkeeping purposes and are no longer actively maintained.\r\n</p>";

    // Replace old intro with new intro.
    // Match from start to the first <section> tag.
    $content = preg_replace(
      '/^.*?(<section class="archive-option">)/s',
      $new_intro . "\r\n\r\n$1",
      $content
    );

    $archive_view->set('display.default.display_options.header.area_text_custom.content', $content);
    $archive_view->save();
  }

  return t('Updated digital_asset_archive view header content.');
}

/**
 * Add flag_prior_void field to digital_asset_archive entity.
 *
 * This flag indicates the archive was forced to General Archive due to a
 * prior exemption_void record for the same file/URL.
 */
function digital_asset_inventory_update_10005() {
  $entity_type_manager = \Drupal::entityTypeManager();
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();

  // Define the new field.
  $field_definition = \Drupal\Core\Field\BaseFieldDefinition::create('boolean')
    ->setLabel(t('Prior Exemption Voided'))
    ->setDescription(t('Warning flag indicating this entry was forced to General Archive due to a prior voided exemption.'))
    ->setDefaultValue(FALSE)
    ->setDisplayOptions('view', [
      'label' => 'above',
      'type' => 'boolean',
      'weight' => 7,
    ])
    ->setDisplayConfigurable('view', TRUE);

  // Install the new field.
  $entity_definition_update_manager->installFieldStorageDefinition(
    'flag_prior_void',
    'digital_asset_archive',
    'digital_asset_inventory',
    $field_definition
  );

  return t('Added flag_prior_void field to digital_asset_archive entity.');
}

/**
 * Add footer area to digital_asset_usage view for back button.
 *
 * Moves the "Return to Inventory" link from the header to a styled button
 * in the footer area, displayed after the usage table.
 */
function digital_asset_inventory_update_10006() {
  $config_factory = \Drupal::configFactory();
  $usage_view = $config_factory->getEditable('views.view.digital_asset_usage');

  if ($usage_view->isNew()) {
    return t('digital_asset_usage view not found.');
  }

  // Add footer area with back button.
  $footer = [
    'asset_info_footer' => [
      'id' => 'asset_info_footer',
      'table' => 'digital_asset_usage',
      'field' => 'asset_info_footer',
      'relationship' => 'none',
      'group_type' => 'group',
      'admin_label' => '',
      'plugin_id' => 'digital_asset_info_footer',
      'empty' => TRUE,
    ],
  ];

  $usage_view->set('display.default.display_options.footer', $footer);
  $usage_view->save();

  // Clear plugin caches to ensure new Views plugins are discovered.
  \Drupal::service('plugin.cache_clearer')->clearCachedDefinitions();

  return t('Added footer area to digital_asset_usage view with back button.');
}

/**
 * Add asset_type and category fields to inventory CSV export.
 */
function digital_asset_inventory_update_10007() {
  $config_factory = \Drupal::configFactory();
  $inventory_view = $config_factory->getEditable('views.view.digital_assets');

  if ($inventory_view->isNew()) {
    return t('digital_assets view not found.');
  }

  // Define the new fields to add to CSV export.
  $field_template = [
    'relationship' => 'none',
    'group_type' => 'group',
    'admin_label' => '',
    'plugin_id' => 'field',
    'exclude' => FALSE,
    'alter' => [
      'alter_text' => FALSE,
      'text' => '',
      'make_link' => FALSE,
      'path' => '',
      'absolute' => FALSE,
      'external' => FALSE,
      'replace_spaces' => FALSE,
      'path_case' => 'none',
      'trim_whitespace' => FALSE,
      'alt' => '',
      'rel' => '',
      'link_class' => '',
      'prefix' => '',
      'suffix' => '',
      'target' => '',
      'nl2br' => FALSE,
      'max_length' => 0,
      'word_boundary' => TRUE,
      'ellipsis' => TRUE,
      'more_link' => FALSE,
      'more_link_text' => '',
      'more_link_path' => '',
      'strip_tags' => FALSE,
      'trim' => FALSE,
      'preserve_tags' => '',
      'html' => FALSE,
    ],
    'element_type' => '',
    'element_class' => '',
    'element_label_type' => '',
    'element_label_class' => '',
    'element_label_colon' => FALSE,
    'element_wrapper_type' => '',
    'element_wrapper_class' => '',
    'element_default_classes' => TRUE,
    'empty' => '',
    'hide_empty' => FALSE,
    'empty_zero' => FALSE,
    'hide_alter_empty' => TRUE,
  ];

  // Get current CSV export fields.
  $csv_fields = $inventory_view->get('display.data_export_csv_inventory.display_options.fields');

  if (!$csv_fields) {
    return t('CSV export display not found in digital_assets view.');
  }

  // Build new fields array with asset_type and category added.
  $new_fields = [];

  foreach ($csv_fields as $key => $field) {
    $new_fields[$key] = $field;

    // After file_path, add asset_type and category.
    if ($key === 'file_path') {
      // Add asset_type field.
      $new_fields['asset_type'] = array_merge($field_template, [
        'id' => 'asset_type',
        'table' => 'digital_asset_item',
        'field' => 'asset_type',
        'label' => 'Asset Type',
      ]);

      // Add category field.
      $new_fields['category'] = array_merge($field_template, [
        'id' => 'category',
        'table' => 'digital_asset_item',
        'field' => 'category',
        'label' => 'Category',
      ]);
    }

    // Update mime_type label from "Type" to "MIME Type".
    if ($key === 'mime_type') {
      $new_fields[$key]['label'] = 'MIME Type';
    }
  }

  $inventory_view->set('display.data_export_csv_inventory.display_options.fields', $new_fields);
  $inventory_view->save();

  return t('Added asset_type and category fields to inventory CSV export.');
}

/**
 * Update public_archive view CSS class names for namespace collision avoidance.
 *
 * Changes 'archive-registry-intro' to 'dai-archive-registry-intro' in both
 * header and empty state areas to avoid potential conflicts with other
 * modules or themes using similar class names.
 */
function digital_asset_inventory_update_10008() {
  $config_factory = \Drupal::configFactory();
  $public_view = $config_factory->getEditable('views.view.public_archive');

  if ($public_view->isNew()) {
    return t('public_archive view not found.');
  }

  $updated = FALSE;

  // Update header content.
  $header_content = $public_view->get('display.default.display_options.header.area_text_custom.content');
  if ($header_content && strpos($header_content, 'class="archive-registry-intro"') !== FALSE) {
    $header_content = str_replace('class="archive-registry-intro"', 'class="dai-archive-registry-intro"', $header_content);
    $public_view->set('display.default.display_options.header.area_text_custom.content', $header_content);
    $updated = TRUE;
  }

  // Update empty state content.
  $empty_content = $public_view->get('display.default.display_options.empty.area_text_custom.content');
  if ($empty_content && strpos($empty_content, 'class="archive-registry-intro"') !== FALSE) {
    $empty_content = str_replace('class="archive-registry-intro"', 'class="dai-archive-registry-intro"', $empty_content);
    $public_view->set('display.default.display_options.empty.area_text_custom.content', $empty_content);
    $updated = TRUE;
  }

  if ($updated) {
    $public_view->save();
    return t('Updated public_archive view CSS class names for namespace collision avoidance.');
  }

  return t('public_archive view CSS class names already up to date.');
}

/**
 * Add file_name filter to digital_assets inventory view.
 *
 * Adds a text input filter for searching assets by file name using
 * "contains" matching for partial searches.
 */
function digital_asset_inventory_update_10009() {
  $config_factory = \Drupal::configFactory();
  $inventory_view = $config_factory->getEditable('views.view.digital_assets');

  if ($inventory_view->isNew()) {
    return t('digital_assets view not found.');
  }

  // Check if file_name filter already exists.
  $existing_filters = $inventory_view->get('display.default.display_options.filters');
  if (isset($existing_filters['file_name'])) {
    return t('file_name filter already exists in digital_assets view.');
  }

  // Define the file_name filter configuration.
  $file_name_filter = [
    'id' => 'file_name',
    'table' => 'digital_asset_item',
    'field' => 'file_name',
    'relationship' => 'none',
    'group_type' => 'group',
    'admin_label' => '',
    'plugin_id' => 'string',
    'operator' => 'contains',
    'value' => '',
    'group' => 1,
    'exposed' => TRUE,
    'expose' => [
      'operator_id' => 'dai_file_name_op',
      'label' => 'File Name',
      'description' => 'Search by file name (partial match)',
      'use_operator' => FALSE,
      'operator' => 'dai_file_name_op',
      'identifier' => 'dai_file_name',
      'required' => FALSE,
      'remember' => TRUE,
      'multiple' => FALSE,
      'placeholder' => 'Search by file name...',
    ],
    'is_grouped' => FALSE,
  ];

  // Add file_name filter at the beginning of filters array.
  $new_filters = ['file_name' => $file_name_filter] + $existing_filters;
  $inventory_view->set('display.default.display_options.filters', $new_filters);

  // Add BEF configuration for file_name filter.
  $bef_config = $inventory_view->get('display.default.display_options.exposed_form.options.bef');
  if (!isset($bef_config['filter'])) {
    $bef_config['filter'] = [];
  }
  $bef_config['filter']['dai_file_name'] = [
    'plugin_id' => 'default',
  ];
  $inventory_view->set('display.default.display_options.exposed_form.options.bef', $bef_config);

  $inventory_view->save();

  return t('Added file_name filter to digital_assets inventory view.');
}

/**
 * Install archive notes system: entity, permissions, and views field.
 *
 * Adds the dai_archive_note entity for storing internal notes on archives,
 * grants permissions to digital_asset_manager role, and adds notes link
 * field to the archive management view.
 */
function digital_asset_inventory_update_10010() {
  $messages = [];

  // 1. Install the new entity type schema.
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();

  // Check if entity type already exists (idempotent).
  if (!$entity_definition_update_manager->getEntityType('dai_archive_note')) {
    // Clear plugin caches to ensure entity type is discovered.
    \Drupal::service('plugin.cache_clearer')->clearCachedDefinitions();

    $entity_type_manager = \Drupal::entityTypeManager();
    try {
      $entity_type = $entity_type_manager->getDefinition('dai_archive_note');
      $entity_definition_update_manager->installEntityType($entity_type);
      $messages[] = t('Installed dai_archive_note entity type.');
    }
    catch (\Exception $e) {
      \Drupal::logger('digital_asset_inventory')->error('Failed to install dai_archive_note entity: @error', [
        '@error' => $e->getMessage(),
      ]);
      $messages[] = t('Failed to install dai_archive_note entity type. Clear cache and try again.');
    }
  }
  else {
    $messages[] = t('dai_archive_note entity type already exists.');
  }

  // 2. Grant permissions to digital_asset_manager role.
  $role = \Drupal\user\Entity\Role::load('digital_asset_manager');
  if ($role) {
    $permissions_added = [];
    if (!$role->hasPermission('view archive internal notes')) {
      $role->grantPermission('view archive internal notes');
      $permissions_added[] = 'view archive internal notes';
    }
    if (!$role->hasPermission('add archive internal notes')) {
      $role->grantPermission('add archive internal notes');
      $permissions_added[] = 'add archive internal notes';
    }
    if ($permissions_added) {
      $role->save();
      $messages[] = t('Granted permissions to digital_asset_manager: @perms', [
        '@perms' => implode(', ', $permissions_added),
      ]);
    }
  }

  // 3. Add notes link field to archive management view.
  $config_factory = \Drupal::configFactory();
  $archive_view = $config_factory->getEditable('views.view.digital_asset_archive');

  if (!$archive_view->isNew()) {
    $fields = $archive_view->get('display.default.display_options.fields');

    // Check if notes_link field already exists.
    if (!isset($fields['notes_link'])) {
      // Add notes link field configuration after archive_reason (Purpose).
      $notes_link_field = [
        'id' => 'notes_link',
        'table' => 'digital_asset_archive',
        'field' => 'archive_notes_link',
        'relationship' => 'none',
        'group_type' => 'group',
        'admin_label' => 'Internal Notes',
        'plugin_id' => 'dai_archive_notes_link',
        'label' => 'Internal Notes',
        'exclude' => FALSE,
        'alter' => [
          'alter_text' => FALSE,
          'text' => '',
          'make_link' => FALSE,
          'path' => '',
          'absolute' => FALSE,
          'external' => FALSE,
          'replace_spaces' => FALSE,
          'path_case' => 'none',
          'trim_whitespace' => FALSE,
          'alt' => '',
          'rel' => '',
          'link_class' => '',
          'prefix' => '',
          'suffix' => '',
          'target' => '',
          'nl2br' => FALSE,
          'max_length' => 0,
          'word_boundary' => TRUE,
          'ellipsis' => TRUE,
          'more_link' => FALSE,
          'more_link_text' => '',
          'more_link_path' => '',
          'strip_tags' => FALSE,
          'trim' => FALSE,
          'preserve_tags' => '',
          'html' => FALSE,
        ],
        'element_type' => '',
        'element_class' => '',
        'element_label_type' => '',
        'element_label_class' => '',
        'element_label_colon' => TRUE,
        'element_wrapper_type' => '',
        'element_wrapper_class' => '',
        'element_default_classes' => TRUE,
        'empty' => '',
        'hide_empty' => FALSE,
        'empty_zero' => FALSE,
        'hide_alter_empty' => TRUE,
      ];

      // Insert after archive_reason to maintain logical grouping.
      $new_fields = [];
      foreach ($fields as $key => $value) {
        $new_fields[$key] = $value;
        if ($key === 'archive_reason') {
          $new_fields['notes_link'] = $notes_link_field;
        }
      }
      // Fallback: if archive_reason not found, append at end.
      if (!isset($new_fields['notes_link'])) {
        $new_fields['notes_link'] = $notes_link_field;
      }

      $archive_view->set('display.default.display_options.fields', $new_fields);
      $archive_view->save();
      $messages[] = t('Added notes_link field to archive management view.');
    }
    else {
      $messages[] = t('notes_link field already exists in archive management view.');
    }
  }

  return implode(' ', $messages);
}

/**
 * Fix heading hierarchy in archive management view (h3 to h2).
 */
function digital_asset_inventory_update_10011() {
  $config_factory = \Drupal::configFactory();
  $archive_view = $config_factory->getEditable('views.view.digital_asset_archive');

  if (!$archive_view->isNew()) {
    $header_content = $archive_view->get('display.default.display_options.header.area_text_custom.content');

    if ($header_content && strpos($header_content, '<h3>Archive Documents') !== FALSE) {
      // Replace h3 with h2 for proper heading hierarchy.
      $header_content = str_replace(
        '<h3>Archive Documents and Videos</h3>',
        '<h2>Archive Documents and Videos</h2>',
        $header_content
      );
      $archive_view->set('display.default.display_options.header.area_text_custom.content', $header_content);
      $archive_view->save();

      return t('Updated archive management view: changed section heading from h3 to h2 for proper heading hierarchy.');
    }
  }

  return t('Archive management view heading already updated or view not found.');
}

/**
 * Simplify permissions: remove notes permissions, add view archives permission.
 *
 * This update:
 * - Removes 'view archive internal notes' and 'add archive internal notes' permissions
 * - Adds 'view digital asset archives' permission for read-only archive access
 * - Updates archive management view to use new access plugin
 *
 * Permission changes:
 * - 'archive digital assets' now includes ability to add notes
 * - 'view digital asset archives' allows viewing archives and notes (read-only)
 */
function digital_asset_inventory_update_10012() {
  $messages = [];

  // 1. Revoke old permissions from all roles.
  $role_storage = \Drupal::entityTypeManager()->getStorage('user_role');
  $roles = $role_storage->loadMultiple();

  $old_permissions = [
    'view archive internal notes',
    'add archive internal notes',
  ];

  foreach ($roles as $role) {
    $revoked = [];
    foreach ($old_permissions as $permission) {
      if ($role->hasPermission($permission)) {
        $role->revokePermission($permission);
        $revoked[] = $permission;
      }
    }
    if ($revoked) {
      $role->save();
      $messages[] = t('Revoked permissions from @role: @perms', [
        '@role' => $role->id(),
        '@perms' => implode(', ', $revoked),
      ]);
    }
  }

  // 2. Update archive management view to use new access plugin.
  $config_factory = \Drupal::configFactory();
  $archive_view = $config_factory->getEditable('views.view.digital_asset_archive');

  if (!$archive_view->isNew()) {
    $current_access = $archive_view->get('display.default.display_options.access');

    // Only update if still using old permission-based access.
    if ($current_access && $current_access['type'] === 'perm') {
      $archive_view->set('display.default.display_options.access', [
        'type' => 'archive_view_access',
        'options' => [],
      ]);
      $archive_view->save();
      $messages[] = t('Updated archive management view to use archive_view_access plugin.');
    }
  }

  if (empty($messages)) {
    return t('No permission updates needed.');
  }

  return implode(' ', $messages);
}

/**
 * Add Alt text and Media columns to usage view.
 */
function digital_asset_inventory_update_10013() {
  $config_path = \Drupal::service('extension.list.module')
    ->getPath('digital_asset_inventory') . '/config/install';
  $source = new \Drupal\Core\Config\FileStorage($config_path);

  // Read the updated view configuration from file.
  $view_config = $source->read('views.view.digital_asset_usage');
  if ($view_config) {
    // Use Config Factory to update existing config (handles overwrites properly).
    \Drupal::configFactory()
      ->getEditable('views.view.digital_asset_usage')
      ->setData($view_config)
      ->save();
    return t('Updated digital_asset_usage view with Alt text and Media columns.');
  }

  return t('Could not find updated view configuration.');
}

/**
 * Remove Times Used column from usage view.
 */
function digital_asset_inventory_update_10014() {
  $config_path = \Drupal::service('extension.list.module')
    ->getPath('digital_asset_inventory') . '/config/install';
  $source = new \Drupal\Core\Config\FileStorage($config_path);

  // Read the updated view configuration from file.
  $view_config = $source->read('views.view.digital_asset_usage');
  if ($view_config) {
    // Use Config Factory to update existing config (handles overwrites properly).
    \Drupal::configFactory()
      ->getEditable('views.view.digital_asset_usage')
      ->setData($view_config)
      ->save();
    return t('Removed Times Used column from digital_asset_usage view.');
  }

  return t('Could not find updated view configuration.');
}

/**
 * Disable sortable header on Source column in inventory view.
 */
function digital_asset_inventory_update_10015() {
  $config_path = \Drupal::service('extension.list.module')
    ->getPath('digital_asset_inventory') . '/config/install';
  $source = new \Drupal\Core\Config\FileStorage($config_path);

  $view_config = $source->read('views.view.digital_assets');
  if ($view_config) {
    \Drupal::configFactory()
      ->getEditable('views.view.digital_assets')
      ->setData($view_config)
      ->save();
    return t('Disabled sortable header on Source column in inventory view.');
  }

  return t('Could not find updated view configuration.');
}

/**
 * Show dash for empty/zero file size and fix Qualtrics category.
 */
function digital_asset_inventory_update_10017() {
  $config_path = \Drupal::service('extension.list.module')
    ->getPath('digital_asset_inventory') . '/config/install';
  $source = new \Drupal\Core\Config\FileStorage($config_path);
  $messages = [];

  // Update view config.
  $view_config = $source->read('views.view.digital_assets');
  if ($view_config) {
    \Drupal::configFactory()
      ->getEditable('views.view.digital_assets')
      ->setData($view_config)
      ->save();
    $messages[] = 'Updated inventory view to show dash for empty/zero file size.';
  }

  // Fix asset type categories.
  $settings = \Drupal::configFactory()->getEditable('digital_asset_inventory.settings');
  $asset_types = $settings->get('asset_types');
  $updated = FALSE;

  // Fix Qualtrics: "Embedded Media" -> "Forms & Surveys".
  if (isset($asset_types['qualtrics']) && $asset_types['qualtrics']['category'] !== 'Forms & Surveys') {
    $asset_types['qualtrics']['category'] = 'Forms & Surveys';
    $updated = TRUE;
    $messages[] = 'Fixed Qualtrics category to Forms & Surveys.';
  }

  // Fix Canva: "Document Services" -> "Embedded Media".
  if (isset($asset_types['canva']) && $asset_types['canva']['category'] !== 'Embedded Media') {
    $asset_types['canva']['category'] = 'Embedded Media';
    $updated = TRUE;
    $messages[] = 'Fixed Canva category to Embedded Media.';
  }

  if ($updated) {
    $settings->set('asset_types', $asset_types)->save();
  }

  return implode(' ', $messages) ?: t('No updates applied.');
}

/**
 * Add archived-while-in-use tracking fields and config setting.
 *
 * This update:
 * - Adds 'archived_while_in_use' field to digital_asset_archive entity
 * - Adds 'usage_count_at_archive' field to digital_asset_archive entity
 * - Adds 'allow_archive_in_use' config setting (defaults to FALSE)
 *
 * When allow_archive_in_use is enabled, documents and videos can be archived
 * even when referenced by active content. Access will be routed through the
 * Archive Detail Page.
 */
function digital_asset_inventory_update_10018() {
  $messages = [];

  // 1. Add new fields to digital_asset_archive entity.
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();

  // Add archived_while_in_use field.
  $archived_while_in_use = \Drupal\Core\Field\BaseFieldDefinition::create('boolean')
    ->setLabel(t('Archived While In Use'))
    ->setDescription(t('Flag indicating this item was archived while still referenced by active content.'))
    ->setDefaultValue(FALSE)
    ->setDisplayOptions('view', [
      'label' => 'above',
      'type' => 'boolean',
      'weight' => 8,
    ])
    ->setDisplayConfigurable('view', TRUE);

  $entity_definition_update_manager->installFieldStorageDefinition(
    'archived_while_in_use',
    'digital_asset_archive',
    'digital_asset_inventory',
    $archived_while_in_use
  );
  $messages[] = t('Added archived_while_in_use field.');

  // Add usage_count_at_archive field.
  $usage_count_at_archive = \Drupal\Core\Field\BaseFieldDefinition::create('integer')
    ->setLabel(t('Usage Count at Archive'))
    ->setDescription(t('Number of active references when the item was archived.'))
    ->setDefaultValue(0)
    ->setDisplayOptions('view', [
      'label' => 'above',
      'type' => 'number_integer',
      'weight' => 9,
    ])
    ->setDisplayConfigurable('view', TRUE);

  $entity_definition_update_manager->installFieldStorageDefinition(
    'usage_count_at_archive',
    'digital_asset_archive',
    'digital_asset_inventory',
    $usage_count_at_archive
  );
  $messages[] = t('Added usage_count_at_archive field.');

  // 2. Add allow_archive_in_use config setting.
  $config = \Drupal::configFactory()->getEditable('digital_asset_inventory.settings');
  if ($config->get('allow_archive_in_use') === NULL) {
    $config->set('allow_archive_in_use', FALSE)->save();
    $messages[] = t('Added allow_archive_in_use config setting (default: FALSE).');
  }

  return implode(' ', $messages);
}

/**
 * Enable archive link filter on HTML text formats.
 *
 * Automatically enables the "Route archived file links to Archive Detail Page"
 * filter on all text formats that output HTML content (Full HTML, Basic HTML,
 * Markdown, etc.). This allows archive link routing to work without manual
 * configuration.
 */
function digital_asset_inventory_update_10019() {
  $updated_formats = _digital_asset_inventory_enable_archive_filter_on_formats();

  if (empty($updated_formats)) {
    return t('No text formats needed updating (filter already enabled or no HTML formats found).');
  }

  return t('Enabled archive link filter on text formats: @formats', [
    '@formats' => implode(', ', $updated_formats),
  ]);
}

/**
 * Remove Media column from usage view (View/Edit Media now in header).
 */
function digital_asset_inventory_update_10020() {
  $view = \Drupal::entityTypeManager()->getStorage('view')->load('digital_asset_usage');
  if (!$view) {
    return t('Usage view not found.');
  }

  $display = &$view->getDisplay('default');

  // Remove usage_media_actions from fields.
  if (isset($display['display_options']['fields']['usage_media_actions'])) {
    unset($display['display_options']['fields']['usage_media_actions']);
  }

  // Remove from table columns.
  if (isset($display['display_options']['style']['options']['columns']['usage_media_actions'])) {
    unset($display['display_options']['style']['options']['columns']['usage_media_actions']);
  }

  // Remove from table info.
  if (isset($display['display_options']['style']['options']['info']['usage_media_actions'])) {
    unset($display['display_options']['style']['options']['info']['usage_media_actions']);
  }

  $view->save();

  return t('Removed Media column from usage view (View/Edit Media links available in header).');
}

/**
 * Update archive view status filter label for consistency (Admin-only → Admin).
 */
function digital_asset_inventory_update_10021() {
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('views.view.digital_asset_archive');

  if ($config->isNew()) {
    return t('Archive view not found.');
  }

  $data = $config->getRawData();

  // Update the status filter options in the default display.
  if (isset($data['display']['default']['display_options']['filters']['status']['group_info']['group_items'])) {
    foreach ($data['display']['default']['display_options']['filters']['status']['group_info']['group_items'] as $key => &$item) {
      if (isset($item['title']) && $item['title'] === 'Archived (Admin-only)') {
        $item['title'] = 'Archived (Admin-Only)';
      }
      elseif (isset($item['title']) && $item['title'] === 'Archived (Admin)') {
        $item['title'] = 'Archived (Admin-Only)';
      }
    }
    unset($item);
  }

  $config->setData($data);
  $config->save();

  return t('Updated archive view status filter label to "Archived (Admin-Only)".');
}

/**
 * Update archive view status filter label from "Archived (Admin)" to "Archived (Admin-Only)".
 */
function digital_asset_inventory_update_10022() {
  $config = \Drupal::configFactory()->getEditable('views.view.digital_asset_archive');

  if ($config->isNew()) {
    return t('Archive view not found.');
  }

  $data = $config->getRawData();

  // Update the status filter options in the default display.
  if (isset($data['display']['default']['display_options']['filters']['status']['group_info']['group_items'])) {
    foreach ($data['display']['default']['display_options']['filters']['status']['group_info']['group_items'] as $key => &$item) {
      if (isset($item['title']) && $item['title'] === 'Archived (Admin)') {
        $item['title'] = 'Archived (Admin-Only)';
      }
    }
    unset($item);
  }

  $config->setData($data);
  $config->save();

  return t('Updated archive view status filter label: "Archived (Admin)" → "Archived (Admin-Only)".');
}

/**
 * Update archive view status field to use custom plugin with accessible titles.
 */
function digital_asset_inventory_update_10023() {
  $config = \Drupal::configFactory()->getEditable('views.view.digital_asset_archive');

  if ($config->isNew()) {
    return t('Archive view not found.');
  }

  $data = $config->getRawData();

  // Update the status field plugin_id in the default display.
  if (isset($data['display']['default']['display_options']['fields']['status']['plugin_id'])) {
    $data['display']['default']['display_options']['fields']['status']['plugin_id'] = 'digital_asset_archive_status';
  }

  $config->setData($data);
  $config->save();

  return t('Updated archive view status field to use custom plugin with accessible title attributes.');
}

/**
 * Add Archive Type badge field to archive management view.
 */
function digital_asset_inventory_update_10024() {
  $config = \Drupal::configFactory()->getEditable('views.view.digital_asset_archive');

  if ($config->isNew()) {
    return t('Archive view not found.');
  }

  $data = $config->getRawData();

  // Add archive_type_badge field after status field.
  $archive_type_field = [
    'id' => 'archive_type_badge',
    'table' => 'digital_asset_archive',
    'field' => 'archive_type_badge',
    'relationship' => 'none',
    'group_type' => 'group',
    'admin_label' => '',
    'plugin_id' => 'digital_asset_archive_type',
    'label' => 'Archive Type',
    'exclude' => FALSE,
    'alter' => [
      'alter_text' => FALSE,
      'text' => '',
      'make_link' => FALSE,
      'path' => '',
      'absolute' => FALSE,
      'external' => FALSE,
      'replace_spaces' => FALSE,
      'path_case' => 'none',
      'trim_whitespace' => FALSE,
      'alt' => '',
      'rel' => '',
      'link_class' => '',
      'prefix' => '',
      'suffix' => '',
      'target' => '',
      'nl2br' => FALSE,
      'max_length' => 0,
      'word_boundary' => TRUE,
      'ellipsis' => TRUE,
      'more_link' => FALSE,
      'more_link_text' => '',
      'more_link_path' => '',
      'strip_tags' => FALSE,
      'trim' => FALSE,
      'preserve_tags' => '',
      'html' => FALSE,
    ],
    'element_type' => '',
    'element_class' => '',
    'element_label_type' => '',
    'element_label_class' => '',
    'element_label_colon' => TRUE,
    'element_wrapper_type' => '',
    'element_wrapper_class' => '',
    'element_default_classes' => TRUE,
    'empty' => '',
    'hide_empty' => FALSE,
    'empty_zero' => FALSE,
    'hide_alter_empty' => TRUE,
  ];

  // Add field to fields array.
  if (isset($data['display']['default']['display_options']['fields'])) {
    $data['display']['default']['display_options']['fields']['archive_type_badge'] = $archive_type_field;
  }

  // Add to table columns.
  if (isset($data['display']['default']['display_options']['style']['options']['columns'])) {
    $data['display']['default']['display_options']['style']['options']['columns']['archive_type_badge'] = 'archive_type_badge';
  }

  // Add to table info.
  if (isset($data['display']['default']['display_options']['style']['options']['info'])) {
    $data['display']['default']['display_options']['style']['options']['info']['archive_type_badge'] = [
      'sortable' => FALSE,
      'default_sort_order' => 'asc',
      'align' => '',
      'separator' => '',
      'empty_column' => FALSE,
      'responsive' => '',
    ];
  }

  $config->setData($data);
  $config->save();

  return t('Added Archive Type badge field to archive management view.');
}

/**
 * Remove Archive Type badge field from archive management view.
 */
function digital_asset_inventory_update_10026() {
  $config = \Drupal::configFactory()->getEditable('views.view.digital_asset_archive');

  if ($config->isNew()) {
    return t('Archive view not found.');
  }

  $data = $config->getRawData();

  // Remove archive_type_badge field.
  if (isset($data['display']['default']['display_options']['fields']['archive_type_badge'])) {
    unset($data['display']['default']['display_options']['fields']['archive_type_badge']);
  }

  // Remove from table columns.
  if (isset($data['display']['default']['display_options']['style']['options']['columns']['archive_type_badge'])) {
    unset($data['display']['default']['display_options']['style']['options']['columns']['archive_type_badge']);
  }

  // Remove from table info.
  if (isset($data['display']['default']['display_options']['style']['options']['info']['archive_type_badge'])) {
    unset($data['display']['default']['display_options']['style']['options']['info']['archive_type_badge']);
  }

  $config->setData($data);
  $config->save();

  return t('Removed Archive Type badge field from archive management view.');
}

/**
 * Replace status field with status_badge pseudo-field for accessible titles.
 */
function digital_asset_inventory_update_10027() {
  $config = \Drupal::configFactory()->getEditable('views.view.digital_asset_archive');

  if ($config->isNew()) {
    return t('Archive view not found.');
  }

  $data = $config->getRawData();

  // Remove old status field.
  if (isset($data['display']['default']['display_options']['fields']['status'])) {
    unset($data['display']['default']['display_options']['fields']['status']);
  }

  // Add new status_badge field.
  $data['display']['default']['display_options']['fields']['status_badge'] = [
    'id' => 'status_badge',
    'table' => 'digital_asset_archive',
    'field' => 'status_badge',
    'relationship' => 'none',
    'group_type' => 'group',
    'admin_label' => '',
    'plugin_id' => 'digital_asset_archive_status',
    'label' => 'Status',
    'exclude' => FALSE,
    'alter' => [
      'alter_text' => FALSE,
      'text' => '',
      'make_link' => FALSE,
      'path' => '',
      'absolute' => FALSE,
      'external' => FALSE,
      'replace_spaces' => FALSE,
      'path_case' => 'none',
      'trim_whitespace' => FALSE,
      'alt' => '',
      'rel' => '',
      'link_class' => '',
      'prefix' => '',
      'suffix' => '',
      'target' => '',
      'nl2br' => FALSE,
      'max_length' => 0,
      'word_boundary' => TRUE,
      'ellipsis' => TRUE,
      'more_link' => FALSE,
      'more_link_text' => '',
      'more_link_path' => '',
      'strip_tags' => FALSE,
      'trim' => FALSE,
      'preserve_tags' => '',
      'html' => FALSE,
    ],
    'element_type' => '',
    'element_class' => '',
    'element_label_type' => '',
    'element_label_class' => '',
    'element_label_colon' => TRUE,
    'element_wrapper_type' => '',
    'element_wrapper_class' => '',
    'element_default_classes' => TRUE,
    'empty' => '',
    'hide_empty' => FALSE,
    'empty_zero' => FALSE,
    'hide_alter_empty' => TRUE,
  ];

  // Update table columns.
  if (isset($data['display']['default']['display_options']['style']['options']['columns']['status'])) {
    unset($data['display']['default']['display_options']['style']['options']['columns']['status']);
    $data['display']['default']['display_options']['style']['options']['columns']['status_badge'] = 'status_badge';
  }

  // Update table info.
  if (isset($data['display']['default']['display_options']['style']['options']['info']['status'])) {
    unset($data['display']['default']['display_options']['style']['options']['info']['status']);
    $data['display']['default']['display_options']['style']['options']['info']['status_badge'] = [
      'sortable' => FALSE,
      'default_sort_order' => 'asc',
      'align' => '',
      'separator' => '',
      'empty_column' => FALSE,
      'responsive' => '',
    ];
  }

  $config->setData($data);
  $config->save();

  return t('Replaced status field with status_badge pseudo-field for accessible titles.');
}

/**
 * Reorder columns to place status_badge before warnings.
 */
function digital_asset_inventory_update_10028() {
  $config = \Drupal::configFactory()->getEditable('views.view.digital_asset_archive');

  if ($config->isNew()) {
    return t('Archive view not found.');
  }

  $data = $config->getRawData();

  // Reorder columns to place status_badge before warnings.
  if (isset($data['display']['default']['display_options']['style']['options']['columns'])) {
    $data['display']['default']['display_options']['style']['options']['columns'] = [
      'archive_path' => 'file_name',
      'file_name' => 'file_name',
      'asset_type' => 'asset_type',
      'status_badge' => 'status_badge',
      'warnings' => 'warnings',
      'archive_reason' => 'archive_reason',
      'notes_link' => 'notes_link',
      'archived_by' => 'archived_by',
      'created' => 'created',
      'archive_classification_date' => 'archive_classification_date',
      'operations' => 'operations',
    ];
  }

  $config->setData($data);
  $config->save();

  return t('Reordered columns: status_badge now before warnings.');
}

/**
 * Reorder fields array to place status_badge before warnings.
 */
function digital_asset_inventory_update_10029() {
  $config = \Drupal::configFactory()->getEditable('views.view.digital_asset_archive');

  if ($config->isNew()) {
    return t('Archive view not found.');
  }

  $data = $config->getRawData();

  // Get current fields.
  $fields = $data['display']['default']['display_options']['fields'] ?? [];

  // Build new ordered fields array.
  $ordered_fields = [];
  $status_badge_field = NULL;

  // First, extract status_badge if it exists.
  if (isset($fields['status_badge'])) {
    $status_badge_field = $fields['status_badge'];
    unset($fields['status_badge']);
  }

  // Now rebuild in correct order, inserting status_badge before warnings.
  foreach ($fields as $key => $field) {
    if ($key === 'warnings' && $status_badge_field !== NULL) {
      $ordered_fields['status_badge'] = $status_badge_field;
    }
    $ordered_fields[$key] = $field;
  }

  // If warnings wasn't found, add status_badge at end.
  if ($status_badge_field !== NULL && !isset($ordered_fields['status_badge'])) {
    $ordered_fields['status_badge'] = $status_badge_field;
  }

  $data['display']['default']['display_options']['fields'] = $ordered_fields;

  $config->setData($data);
  $config->save();

  return t('Reordered fields: status_badge now before warnings.');
}

/**
 * Add archive status filter to inventory view.
 */
function digital_asset_inventory_update_10030() {
  $config = \Drupal::configFactory()->getEditable('views.view.digital_assets');

  if ($config->isNew()) {
    return t('Inventory view not found.');
  }

  $data = $config->getRawData();

  // Check if filter already exists.
  if (isset($data['display']['default']['display_options']['filters']['archive_status'])) {
    return t('Archive status filter already exists.');
  }

  // Add the archive_status filter.
  $data['display']['default']['display_options']['filters']['archive_status'] = [
    'id' => 'archive_status',
    'table' => 'digital_asset_item',
    'field' => 'archive_status',
    'relationship' => 'none',
    'group_type' => 'group',
    'admin_label' => '',
    'plugin_id' => 'digital_asset_archive_status_filter',
    'operator' => '=',
    'value' => 'All',
    'group' => 1,
    'exposed' => TRUE,
    'expose' => [
      'operator_id' => '',
      'label' => 'Archive Status',
      'description' => '',
      'use_operator' => FALSE,
      'operator' => '',
      'identifier' => 'archive_status',
      'required' => FALSE,
      'remember' => TRUE,
      'multiple' => FALSE,
    ],
    'is_grouped' => FALSE,
  ];

  $config->setData($data);
  $config->save();

  return t('Added archive status filter to inventory view.');
}

/**
 * Add allow_archive_in_use setting.
 */
function digital_asset_inventory_update_10031() {
  $config = \Drupal::configFactory()->getEditable('digital_asset_inventory.settings');

  // Only add if not already set.
  if ($config->get('allow_archive_in_use') === NULL) {
    $config->set('allow_archive_in_use', FALSE);
    $config->save();
    return t('Added allow_archive_in_use setting (default: FALSE).');
  }

  return t('allow_archive_in_use setting already exists.');
}

/**
 * Update archive view: change status field to status_badge with custom plugin.
 */
function digital_asset_inventory_update_10032() {
  $config = \Drupal::configFactory()->getEditable('views.view.digital_asset_archive');

  if ($config->isNew()) {
    return t('Archive view not found.');
  }

  $data = $config->getRawData();
  $fields = &$data['display']['default']['display_options']['fields'];

  // Check if already updated.
  if (isset($fields['status_badge'])) {
    return t('Archive view already has status_badge field.');
  }

  // Check if old status field exists.
  if (!isset($fields['status'])) {
    return t('Status field not found in archive view.');
  }

  // Create new status_badge field based on old status field.
  $old_status = $fields['status'];
  $new_status_badge = $old_status;
  $new_status_badge['id'] = 'status_badge';
  $new_status_badge['field'] = 'status_badge';
  $new_status_badge['plugin_id'] = 'digital_asset_archive_status';
  unset($new_status_badge['type']);

  // Remove old status field and add new one in same position.
  $new_fields = [];
  foreach ($fields as $key => $field) {
    if ($key === 'status') {
      $new_fields['status_badge'] = $new_status_badge;
    }
    else {
      $new_fields[$key] = $field;
    }
  }
  $data['display']['default']['display_options']['fields'] = $new_fields;

  // Update table columns mapping.
  if (isset($data['display']['default']['display_options']['style']['options']['columns']['status'])) {
    $data['display']['default']['display_options']['style']['options']['columns']['status_badge'] =
      $data['display']['default']['display_options']['style']['options']['columns']['status'];
    unset($data['display']['default']['display_options']['style']['options']['columns']['status']);
  }

  // Update table info.
  if (isset($data['display']['default']['display_options']['style']['options']['info']['status'])) {
    $info = $data['display']['default']['display_options']['style']['options']['info']['status'];
    $info['sortable'] = FALSE;
    $data['display']['default']['display_options']['style']['options']['info']['status_badge'] = $info;
    unset($data['display']['default']['display_options']['style']['options']['info']['status']);
  }

  // Fix "Admin-only" capitalization in status filter.
  if (isset($data['display']['default']['display_options']['filters']['status']['group_info']['group_items'])) {
    foreach ($data['display']['default']['display_options']['filters']['status']['group_info']['group_items'] as &$item) {
      if ($item['title'] === 'Archived (Admin-only)') {
        $item['title'] = 'Archived (Admin-Only)';
      }
    }
  }

  $config->setData($data);
  $config->save();

  return t('Updated archive view: status field changed to status_badge with custom plugin.');
}

/**
 * Remove usage_media_actions field from usage view.
 */
function digital_asset_inventory_update_10033() {
  $config = \Drupal::configFactory()->getEditable('views.view.digital_asset_usage');

  if ($config->isNew()) {
    return t('Usage view not found.');
  }

  $data = $config->getRawData();
  $changed = FALSE;

  // Remove usage_media_actions field.
  if (isset($data['display']['default']['display_options']['fields']['usage_media_actions'])) {
    unset($data['display']['default']['display_options']['fields']['usage_media_actions']);
    $changed = TRUE;
  }

  // Remove from table columns.
  if (isset($data['display']['default']['display_options']['style']['options']['columns']['usage_media_actions'])) {
    unset($data['display']['default']['display_options']['style']['options']['columns']['usage_media_actions']);
    $changed = TRUE;
  }

  // Remove from table info.
  if (isset($data['display']['default']['display_options']['style']['options']['info']['usage_media_actions'])) {
    unset($data['display']['default']['display_options']['style']['options']['info']['usage_media_actions']);
    $changed = TRUE;
  }

  if ($changed) {
    $config->setData($data);
    $config->save();
    return t('Removed usage_media_actions field from usage view.');
  }

  return t('usage_media_actions field not found in usage view.');
}

/**
 * Normalize existing external URL archives for consistent matching.
 *
 * External URLs are normalized using ArchiveService::normalizeUrl() which:
 * - Lowercases scheme and host
 * - Removes default ports (:80 for http, :443 for https)
 * - Removes trailing slashes (except root "/")
 * - Preserves query strings
 * - Removes fragment identifiers
 */
function digital_asset_inventory_update_10034() {
  $storage = \Drupal::entityTypeManager()->getStorage('digital_asset_archive');
  $archive_service = \Drupal::service('digital_asset_inventory.archive');

  // Find all external URL archives.
  $ids = $storage->getQuery()
    ->accessCheck(FALSE)
    ->condition('asset_type', 'external')
    ->execute();

  $updated = 0;
  foreach ($storage->loadMultiple($ids) as $archive) {
    $original = $archive->getOriginalPath();
    if (!empty($original) && strpos($original, 'http') === 0) {
      $normalized = $archive_service->normalizeUrl($original);
      if ($normalized !== $original) {
        $archive->set('original_path', $normalized);
        $archive->set('archive_path', $normalized);
        $archive->save();
        $updated++;
      }
    }
  }

  return t('Normalized @count external URL archives.', ['@count' => $updated]);
}

/**
 * Add default values for new label configuration settings.
 *
 * These settings control the archived link label:
 * - show_archived_label: Whether to display the label on archived links
 * - archived_label_text: The text to display (defaults to "Archived")
 */
function digital_asset_inventory_update_10035() {
  $config = \Drupal::configFactory()->getEditable('digital_asset_inventory.settings');

  if ($config->get('show_archived_label') === NULL) {
    $config->set('show_archived_label', TRUE);
  }
  if ($config->get('archived_label_text') === NULL) {
    $config->set('archived_label_text', 'Archived');
  }

  $config->save();

  return t('Added default label configuration settings.');
}

/**
 * Remove parentheses from archived_label_text config.
 *
 * The code adds parentheses automatically, so the config value should not
 * include them. This fixes the default from "(Archived)" to "Archived".
 */
function digital_asset_inventory_update_10036() {
  $config = \Drupal::configFactory()->getEditable('digital_asset_inventory.settings');

  $label_text = $config->get('archived_label_text');
  if ($label_text === '(Archived)') {
    $config->set('archived_label_text', 'Archived');
    $config->save();
    return t('Updated archived label text from "(Archived)" to "Archived".');
  }

  return t('No changes needed to archived label text.');
}

/**
 * Add accessibility signal fields to digital_asset_usage entity.
 *
 * Adds three new fields for audio/video accessibility signal tracking:
 * - presentation_type: How media is embedded (AUDIO_HTML5, VIDEO_HTML5, etc.)
 * - accessibility_signals: JSON-encoded accessibility signals
 * - signals_evaluated: Boolean flag for evaluation caching
 */
function digital_asset_inventory_update_10037() {
  $entity_type_manager = \Drupal::entityTypeManager();
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();

  // Get the entity type definition.
  $entity_type = $entity_type_manager->getDefinition('digital_asset_usage');

  // Install the new fields from the updated entity definition.
  // The fields are already defined in DigitalAssetUsage::baseFieldDefinitions().
  // We need to apply them to existing installations.

  // Add presentation_type field.
  $presentation_type_field = \Drupal\Core\Field\BaseFieldDefinition::create('string')
    ->setLabel(t('Presentation Type'))
    ->setDescription(t('How the media is embedded (AUDIO_HTML5, VIDEO_HTML5, etc.)'))
    ->setSettings([
      'max_length' => 32,
      'text_processing' => 0,
    ])
    ->setDefaultValue('');

  $entity_definition_update_manager->installFieldStorageDefinition(
    'presentation_type',
    'digital_asset_usage',
    'digital_asset_inventory',
    $presentation_type_field
  );

  // Add accessibility_signals field (JSON string).
  $signals_field = \Drupal\Core\Field\BaseFieldDefinition::create('string_long')
    ->setLabel(t('Accessibility Signals'))
    ->setDescription(t('JSON-encoded accessibility signals for audio/video.'))
    ->setDefaultValue('');

  $entity_definition_update_manager->installFieldStorageDefinition(
    'accessibility_signals',
    'digital_asset_usage',
    'digital_asset_inventory',
    $signals_field
  );

  // Add signals_evaluated flag.
  $evaluated_field = \Drupal\Core\Field\BaseFieldDefinition::create('boolean')
    ->setLabel(t('Signals Evaluated'))
    ->setDescription(t('Whether accessibility signals have been evaluated for this usage.'))
    ->setDefaultValue(FALSE);

  $entity_definition_update_manager->installFieldStorageDefinition(
    'signals_evaluated',
    'digital_asset_usage',
    'digital_asset_inventory',
    $evaluated_field
  );

  return t('Added accessibility signal fields to digital_asset_usage entity (presentation_type, accessibility_signals, signals_evaluated).');
}

/**
 * Update digital_asset_usage view to add accessibility signal columns.
 *
 * Adds four new columns for audio/video accessibility signals:
 * - Embed Type: How media is embedded (HTML5 Video, Remote Iframe, etc.)
 * - Controls: Whether player controls are present
 * - Captions: Whether captions are available
 * - Transcript: Whether a transcript link is nearby
 *
 * These columns are only shown for audio/video assets.
 */
function digital_asset_inventory_update_10038() {
  $config_path = \Drupal::service('extension.list.module')
    ->getPath('digital_asset_inventory') . '/config/install';
  $source = new \Drupal\Core\Config\FileStorage($config_path);
  $config_storage = \Drupal::service('config.storage');

  // Import updated view configuration.
  $config_storage->write('views.view.digital_asset_usage', $source->read('views.view.digital_asset_usage'));

  return t('Updated digital_asset_usage view to add accessibility signal columns for audio/video assets.');
}

/**
 * Add embed_method field to digital_asset_usage entity.
 *
 * This field tracks how assets are embedded in content:
 * - field_reference: Entity reference field
 * - drupal_media: CKEditor <drupal-media> embed
 * - html5_video: Raw HTML5 <video> tag
 * - html5_audio: Raw HTML5 <audio> tag
 * - text_link: Hyperlink in text content
 * - menu_link: Menu link
 */
function digital_asset_inventory_update_10039() {
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();

  // Check if field already exists.
  $existing = $entity_definition_update_manager->getFieldStorageDefinition('embed_method', 'digital_asset_usage');
  if ($existing) {
    return t('embed_method field already exists.');
  }

  // Add embed_method field.
  $embed_method_field = \Drupal\Core\Field\BaseFieldDefinition::create('string')
    ->setLabel(t('Embed Method'))
    ->setDescription(t('How the asset is embedded (field_reference, drupal_media, html5_video, html5_audio, text_link, menu_link).'))
    ->setSettings([
      'max_length' => 32,
      'text_processing' => 0,
    ])
    ->setDefaultValue('field_reference');

  $entity_definition_update_manager->installFieldStorageDefinition(
    'embed_method',
    'digital_asset_usage',
    'digital_asset_inventory',
    $embed_method_field
  );

  return t('Added embed_method field to digital_asset_usage entity.');
}

/**
 * Add VTT and SRT caption file types to asset_types configuration.
 */
function digital_asset_inventory_update_10040() {
  $config = \Drupal::configFactory()->getEditable('digital_asset_inventory.settings');
  $asset_types = $config->get('asset_types') ?? [];

  // Add VTT type if not exists.
  if (!isset($asset_types['vtt'])) {
    $asset_types['vtt'] = [
      'label' => 'WebVTT Captions',
      'category' => 'Documents',
      'extensions' => ['vtt'],
      'mimes' => ['text/vtt'],
    ];
  }

  // Add SRT type if not exists.
  if (!isset($asset_types['srt'])) {
    $asset_types['srt'] = [
      'label' => 'SRT Subtitles',
      'category' => 'Documents',
      'extensions' => ['srt'],
      'mimes' => ['application/x-subrip', 'text/srt'],
    ];
  }

  $config->set('asset_types', $asset_types);
  $config->save();

  return t('Added VTT and SRT caption file types to asset_types configuration.');
}

/**
 * Remove deprecated ArchiveFileLinkFilter from all text formats.
 *
 * The filter is deprecated because ArchiveLinkResponseSubscriber now handles
 * all archive link routing in the final HTML output, making the text format
 * filter redundant.
 */
function digital_asset_inventory_update_10041() {
  $config_factory = \Drupal::configFactory();
  $filter_id = 'digital_asset_archive_link_filter';
  $formats_updated = [];

  // Get all filter format configurations.
  foreach ($config_factory->listAll('filter.format.') as $config_name) {
    $config = $config_factory->getEditable($config_name);
    $filters = $config->get('filters') ?? [];

    // Check if this format has the deprecated filter.
    if (isset($filters[$filter_id])) {
      // Remove the filter.
      unset($filters[$filter_id]);
      $config->set('filters', $filters);
      $config->save();

      // Extract format name from config name (e.g., 'filter.format.full_html' -> 'full_html').
      $format_name = str_replace('filter.format.', '', $config_name);
      $formats_updated[] = $format_name;
    }
  }

  if (!empty($formats_updated)) {
    return t('Removed deprecated ArchiveFileLinkFilter from text formats: @formats. Archive link routing is now handled automatically by the Response Subscriber.', [
      '@formats' => implode(', ', $formats_updated),
    ]);
  }

  return t('No text formats had the deprecated ArchiveFileLinkFilter configured.');
}

/**
 * Update digital_assets view: File Name filter searches both name and URL.
 *
 * Replaces the single-field file_name string filter with a combine filter
 * that searches both file_name and file_path, so external assets (Google Docs,
 * YouTube, etc.) can be found by URL.
 */
function digital_asset_inventory_update_10042() {
  $config_path = \Drupal::service('extension.list.module')
    ->getPath('digital_asset_inventory') . '/config/install';
  $source = new \Drupal\Core\Config\FileStorage($config_path);
  $config_storage = \Drupal::service('config.storage');

  $config_storage->write('views.view.digital_assets', $source->read('views.view.digital_assets'));

  return t('Updated digital_assets view: File Name filter now searches both file name and URL.');
}

/**
 * Implements hook_uninstall().
 *
 * Note: Drupal blocks module uninstall when content entities have data.
 * Users must manually delete entities before uninstalling:
 *
 * @code
 * drush entity:delete dai_archive_note -y
 * drush entity:delete digital_asset_archive -y
 * drush entity:delete digital_asset_usage -y
 * drush entity:delete digital_asset_item -y
 * drush pm:uninstall digital_asset_inventory -y
 * @endcode
 *
 * The entity deletion code below serves as a safety net for any orphaned
 * records and documents the correct deletion order (notes → archives → usage → items).
 */
function digital_asset_inventory_uninstall() {
  // Note: Entity cleanup is not needed here. Drupal blocks module uninstall
  // when content entities have data. Users must delete entities manually first:
  //
  // drush entity:delete dai_archive_note -y
  // drush entity:delete digital_asset_archive -y
  // drush entity:delete digital_asset_usage -y
  // drush entity:delete digital_asset_item -y
  //
  // By the time hook_uninstall() runs, entity type definitions are already
  // removed, so we cannot use EntityTypeManager here.

  // Clean up state variables.
  \Drupal::state()->delete('digital_asset_inventory.last_scan');
  \Drupal::state()->delete('digital_asset_inventory.scan_start');
  \Drupal::state()->delete('digital_asset_inventory.scan_duration');
  \Drupal::state()->delete('digital_asset_inventory.scan_orphan_count');

  // Explicitly delete module configuration to prevent reinstall conflicts.
  // Enforced dependencies should handle this, but this ensures clean removal.
  $config_factory = \Drupal::configFactory();
  $configs_to_delete = [
    'views.view.digital_assets',
    'views.view.digital_asset_usage',
    'views.view.digital_asset_archive',
    'views.view.public_archive',
    'digital_asset_inventory.settings',
  ];

  foreach ($configs_to_delete as $config_name) {
    try {
      $config = $config_factory->getEditable($config_name);
      if (!$config->isNew()) {
        $config->delete();
      }
    }
    catch (\Exception $e) {
      // Log but don't block uninstall.
      \Drupal::logger('digital_asset_inventory')->warning('Config cleanup during uninstall (@config): @error', [
        '@config' => $config_name,
        '@error' => $e->getMessage(),
      ]);
    }
  }

  \Drupal::messenger()->addStatus(t('Digital Asset Inventory module uninstalled successfully.'));
}

